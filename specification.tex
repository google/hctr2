% Copyright 2021 Google LLC
%
% Use of this source code is governed by an MIT-style
% license that can be found in the LICENSE file or at
% https://opensource.org/licenses/MIT.

%!BIB program = biber
%!TeX program = lualatex
%!TeX spellcheck = en-US

\documentclass[hctr.tex]{subfiles}
\begin{document}
\section{Specification}\label{specification}
\subsection{Notation}
\begin{itemize}
    \item $\abs{X}$: length of $X \in \bin^{*}$ in bits
    \item $\Concat$: bitstring concatenation
    \item \(\xor\): bitwise XOR
    \item $X[a;l]$: the substring of $Y$ of length $l$ starting at the 0-based index $a$
    \item \(n\): block size in bits
    \item $\fromint_l: \{0 \ldots 2^l-1\} \rightarrow \bin^l$:
    little-endian conversion of integers to binary; 
    \(\fromint(x)\) means \(\fromint_n(x)\)
    \item $\pad(X) = X \Concat 0^v$
    where $v$ is the least integer $\geq 0$ such that $n$ divides $\abs{X} + v$
    \item \(E: \mathcal{K} \times \bin^n \rightarrow \bin^n\): 
    \(n\)-bit block cipher with keyspace \(\mathcal{K}\);
    our concrete proposal uses AES\cite{aes},
    so \(n=128\) and \(\mathcal{K}\) is
    \(\bin^{128}\), \(\bin^{192}\), or \(\bin^{256}\)
    \item \(\mathcal{T}\): the set of permissible tweaks
    \(\mathcal{T} = \bigcup_{i \in \{0\ldots2^{n-1}-2\}}\bin^i\)
    \item \(\mathcal{M}\): the set of permissible messages
    \(\mathcal{M} = \bin^n \times \mathcal{T} = \bigcup_{i \in \{n\ldots n + 2^{n-1}-2\}}\bin^i\)
\end{itemize}
We map bytes to bitstrings with \(\fromint_8\). Subscripts may denote partial application; if we define $f: A \times B \rightarrow C$ and
$a \in A$ then $f_a: B \rightarrow C$, and if $f_a^{-1}$ exists then $f_a^{-1}(f_a(b)) = b$.


\subsection{Polynomial hash function}\label{hashspec}
We interpret \(n\)-bit blocks as little-endian field elements of \(\GF(2^n)\),
so \(001 \Concat 0^{n-3}\) is interpreted as the element \(x^2\).
In our concrete proposal, \(n=128\) and we reduce by
\(x^{128} + x^7 + x^2 + x + 1\).
Define
\begin{align*}
    & \poly_h(M_0 \Concat M_1 \Concat \cdots \Concat M_{l-2} \Concat M_{l-1}) \\
    \defeq & M_0h^{l-1} \xor M_1h^{l-2} \xor \cdots \xor M_{l-2}h \xor M_{l-1}
\end{align*}
where \(\abs{M_i} = n\). For tweak \(T\) and message \(M\), we define \(H: \bin^n \times \mathcal{T} \times \mathcal{T}\):
\begin{align*}
    & H_h(T, M) \\
    \defeq & 
    \begin{cases}
        \poly_h(\fromint(2\abs{T} + 2) \Concat \pad(T) \Concat M \Concat 0^n) &
        \text{if } n \text{ divides } \abs{M} \\
        \poly_h(\fromint(2\abs{T} + 3) \Concat \pad(T) \Concat \pad(M \Concat 1) \Concat 0^n) &
        \text{otherwise}
    \end{cases}
\end{align*}

\subsection{XCTR mode}

HCTR and HCTR2 use an unusual mode of stream encryption.
\cite{hctr,hctrquad} note the differences between this mode and 
CTR mode\cite{ctr},
but use the same name to refer to it; for the avoidance of ambiguity
we name this mode \emph{XCTR mode}, and define:
\begin{displaymath}
    \XCTR_k(S) = E_k(S \xor \fromint(1)) \Concat E_k(S \xor \fromint(2)) \Concat E_k(S \xor \fromint(3)) \Concat \cdots
\end{displaymath}
Thus, generating the first \(m\) bits \(\XCTR_k(S)[0; m]\) takes \(\ceil{m/n}\) block cipher calls. 

\subsection{HCTR2 encryption}

From these definitions, HCTR2 is as defined in \autoref{pseudocode}.
Note that what \cite{hctr,hctrquad} refer to as \(C, \mathit{CC}, D\)
we refer to as \(U, \UU, V\)
so that we can use \(P, C\) to refer to plaintext and ciphertext.
\subfile{algorithm.tex}
\end{document}
