% Copyright 2021 Google LLC
%
% Use of this source code is governed by an MIT-style
% license that can be found in the LICENSE file or at
% https://opensource.org/licenses/MIT.

%!BIB program = biber
%!TeX program = lualatex
%!TeX spellcheck = en-US

\documentclass[hctr.tex]{subfiles}
\begin{document}
\section{Specification}\label{specification}
\begin{figure}
    \subfile{hctr2fig.tex}
    \caption{HCTR2}\label{hctr2fig}
\end{figure}
\begin{figure}
    \begin{floatrow}
        \ffigbox{
            \begin{algorithmic}[0]
                \Procedure{\(HCTR2_{k, T}\)}{$P$}
                \State $h \gets E_k(\fromint(0))$
                \State $L \gets E_k(\fromint(1))$
                \State $M \Concat N \gets P$, $|M| = n$
                \State $\MM \gets M \xor H_h(T, N)$
                \State $\UU \gets E_k(\MM)$
                \State $S \gets \MM \xor \UU \xor L$
                \State $V \gets N \xor \XCTR_k(S)[0;\abs{N}]$
                \State $U \gets \UU \xor H_h(T, V)$
                \State $C \gets U \Concat V$
                \State \textbf{return} $C$
                \EndProcedure
            \end{algorithmic}
        }{
            \caption{HCTR2 encryption}\label{pseudocode}
        }
        \ffigbox{
            \begin{algorithmic}[0]
                \Procedure{\(HCTR2_{k, T}^{-1}\)}{$C$}
                \State $h \gets E_k(\fromint(0))$
                \State $L \gets E_k(\fromint(1))$
                \State $U \Concat V \gets C$, $|U| = n$
                \State $\UU \gets U \xor H_h(T, V)$
                \State $\MM \gets E_k^{-1}(\UU)$
                \State $S \gets \MM \xor \UU \xor L$
                \State $N \gets V \xor \XCTR_k(S)[0;\abs{V}]$
                \State $M \gets \MM \xor H_h(T, N)$
                \State $P \gets M \Concat N$
                \State \textbf{return} $P$
                \EndProcedure
            \end{algorithmic}
        }{
            \caption{HCTR2 decryption}
        }
    \end{floatrow}
\end{figure}
\subsection{Notation}
Subscripts may denote partial application; if we define $f: A \times B \rightarrow C$ and
$a \in A$ then $f_a: B \rightarrow C$, and if $f_a^{-1}$ exists then $f_a^{-1}(f_a(b)) = b$.
\begin{itemize}
    \item $\abs{X}$: length of $X \in \bin^{*}$ in bits
    \item $\lambda$: the empty string $\abs{\lambda} = 0$
    \item $\Concat$: bitstring concatenation
    \item \(\xor\): bitwise XOR
    \item $Y[a;l]$: the substring of $Y$ of length $l$ starting at the 0-based index $a$
    \item \(n\): block size in bits
    \item $\fromint_l: \{0 \ldots 2^l-1\} \rightarrow \bin^l$:
    little-endian conversion of integers to binary; 
    \(\fromint(x)\) means \(\fromint_n(x)\)
    \item $\pad(X) = X \Concat 0^v$
    where $v$ is the least integer $\geq 0$ such that $n$ divides $\abs{X} + v$
    \item \(E: \mathcal{K} \times \bin^n \rightarrow \bin^n\): 
    \(n\)-bit block cipher with keyspace \(\mathcal{K}\);
    our concrete proposal uses AES\cite{aes},
    so \(n=128\) and \(\mathcal{K}\) is
    \(\bin^{128}\), \(\bin^{192}\), or \(\bin^{256}\)
    \item \(\mathcal{T}\): the set of permissible tweaks
    \(\mathcal{T} = \bigcup_{i \in \{0\ldots2^{n-1}-2\}}\bin^i\)
    \item \(\mathcal{M}\): the set of permissible messages
    \(\mathcal{M} = \bigcup_{i \in \{n\ldots2^{n-1}-2\}}\bin^i\)
\end{itemize}
We map bytes to bitstrings with \(\fromint_8\).

\subsection{Polynomial hash function}
We interpret \(n\)-bit blocks as little-endian field elements of \(\GF(2^n)\),
so \(001 \Concat 0^{n-3}\) is interpreted as the element \(x^2\).
In our concrete proposal, \(n=128\) and we reduce by
\(1 + x + x^2 + x^7 + x^{128}\). Then let
\begin{displaymath}
    \poly(M_0 \Concat M_1 \Concat \cdots \Concat M_{l-2} \Concat M_{l-1})
\end{displaymath}
refer to the polynomial
\begin{displaymath}
    p(h) = M_0h^{l-1} \xor M_1h^{l-2} \xor \cdots \xor M_{l-2}h \xor M_{l-1}
\end{displaymath}

We define a polynomial for tweak \(T\) and message \(M\):
\begin{displaymath}
    H(T, M) = 
    \begin{cases}
        \poly(\fromint(2\abs{T} + 2) \Concat \pad(T) \Concat M \Concat 0^n) &
        \text{if } n \text{ divides } \abs{M} \\
        \poly(\fromint(2\abs{T} + 3) \Concat \pad(T) \Concat \pad(M \Concat 1) \Concat 0^n) &
        \text{otherwise}
    \end{cases}
\end{displaymath}

We then define our hash function \(H_h(T, M)\) as evaluation
of the polynomial \(H(T, M)\) at \(h\) for key \(h \in \bin^n\).

\subsection{XCTR mode}

HCTR and HCTR2 use an unusual mode of stream encryption.
\cite{hctr,hctrquad} note the differences between this mode and 
CTR mode\cite{ctr},
but use the same name to refer to it; for the avoidance of ambiguity
we name this mode \emph{XCTR mode}, and define:
\begin{displaymath}
    \XCTR_k(S) = E_k(S \xor \fromint(1)) \Concat E_k(S \xor \fromint(2)) \Concat E_k(S \xor \fromint(3)) \Concat \cdots
\end{displaymath}
Thus, generating the first \(m\) bits \(\XCTR_k(S)[0; m]\) takes \(\ceil{m/n}\) block cipher calls. Note also that XCTR is defined to be little endian,
in contrast to CTR which is defined to be big endian.

\subsection{HCTR2 encryption}

From these definitions, HCTR2 is as defined in \autoref{pseudocode}.
Note that what is referred to in \cite{hctr,hctrquad} as \(C, \mathit{CC}, D\)
we refer to as \(U, \UU, V\)
so that we can use \(P, C\) to refer to plaintext and ciphertext.
\end{document}
