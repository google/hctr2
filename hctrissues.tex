% Copyright 2021 Google LLC
%
% Use of this source code is governed by an MIT-style
% license that can be found in the LICENSE file or at
% https://opensource.org/licenses/MIT.

%!BIB program = biber
%!TeX program = lualatex
%!TeX spellcheck = en-US

\documentclass[hctr.tex]{subfiles}
\begin{document}
\section{HCTR issues}\label{hctrissues}
Two errors in previous work on HCTR are addressed in HCTR2.
\subsection{Hash function}
HCTR uses a hash function based on the polynomial
\begin{displaymath}
    H(X) = \poly(\pad(X) \Concat \fromint(\abs{X}) \Concat 0^n)
\end{displaymath}
Because it assumes a fixed-length tweak it simply sets \(X = M \Concat T\).
However, HCTR requires that the resulting polynomial be nonzero
even when \(X = \lambda\), so as a special case they define
\(H(\lambda) = h\).

Unfortunately, as \cite{kumarhctr} observes this is no longer
an injective map from \(X\)---we also have \(H(0) = h\). This
straightforwardly leads to an attack in which two encryption queries
are presented, one of a block width, and the second extending
the first with a single zero (and assuming a zero length tweak).

\subsection{Security bound}
\cite{hctr} was initially presented with a security bound cubic
in the total size of all queries combined.  This is a little low
for comfort; if a 128-bit block cipher is used, it suggests a
distinguisher can be effective given tens of terabytes of queries,
which can quickly be reached over a fast link. 
\cite{hctrquad} presents a much more satisfactory quadratic bound,
but the proof has an error that invalidates the claimed bound.

While presented in a different way, 
the proof of~\cite{hctrquad} is very similar
to that of this paper: in the game RAND2, all queries get random
responses, the block cipher inputs are inferred, and a collision
in either the domain or range of the block cipher
sets the ``bad'' flag. Where that paper refers to 
\(C, \mathit{CC}, D\)
we refer to as \(U, \UU, V\). Where HCTR2 has
\(S = \MM \xor \UU \xor L\), HCTR simply has
\(S = \MM \xor \UU\). HCTR uses a fixed-length tweak
of length \(t\); for simplicity we assume \(t = 0\)
in what follows.

For equation 17, the paper observes that the collision
\(Y_i^r = \UU^s\) occurs iff \(h\) is one of the zeroes
of the polynomial \(Y_i^r \xor U^s \xor H(T^s, V^s)\).
This polynomial has degree at most
\(m^s\), and so can have
at most that many solutions. From this the paper infers
a quadratic bound on the probability of any such collision
given \(\sigma\) input blocks.

In equation 22, the paper considers collisions of the form 
\(S_i^r = \MM^s\) and asserts that they are
quadratically bounded for the same reason. However this equation
is crucially different: unlike with \(Y_i^r\), the value we
infer for \(S_i^r\) depends on \(h\). The values of \(h\)
for which this collision occurs are
the zeroes of the polynomial
\begin{displaymath}
    M^r \xor H(T^r, N^r)
    \xor U^r \xor H(T^r, V^r) \xor \fromint(i) 
    \xor M^s \xor H(T^s, N^s)        
\end{displaymath}
This polynomial can have degree up to 
\(\max(m^r, m^s)\), and so the bound of
equation 17 does not apply.
If queries are permitted to be of any length,
this leads to a cubic security bound.
Consider an adversary who
sends a single query with \(x+1\) blocks, followed by
\(x\) queries of one block. For each \(i \in \{1\ldots x\}\) and
for each \(s \in \{2 \ldots x + 1\}\), we have at best
\(\prob{S_i^r = \MM^s} \leq (x + 1)/2^n\). Summing
all these bounds for each such pair, we find that
for queries with \(\sigma = 2x + 1\)
get a bound for the overall probability of such a collision of 
\((x^3 + x^2)/2^n\).

\cite{nandimail} observes that a quadratic bound can be recovered
if a bound \(l_\mathrm{max}\) is set on the maximum size of
a single query; in this case we get a bound
which is some small multiple of \(l_\mathrm{max}q\sigma/2^n\).
\end{document}
