% Copyright 2021 Google LLC
%
% Use of this source code is governed by an MIT-style
% license that can be found in the LICENSE file or at
% https://opensource.org/licenses/MIT.

%!BIB program = biber
%!TeX program = lualatex
%!TeX spellcheck = en-US

\documentclass[hctr.tex]{subfiles}
\begin{document}
\section{Security of HCTR2}\label{security}
We prove that if the underlying block cipher is secure,
then HCTR2 has good security properties.
\subsection{Definitions}
We use \(x \sample S\) to mean ``\(x\) is sampled from \(S\)
uniformly at random'', and we write
\(A^{\mathcal{O}, \mathcal{O}'}\Rightarrow 1\) to refer
to the event ``adversary \(A\),
given access to oracles \(\mathcal{O}\) and \(\mathcal{O}'\),
returns 1''.

Let $\Perm(n)$ denote the set of all permutations on \(\bin^n\).
Per \cite{concrete}, for a block cipher 
\(E: \mathcal{K} \times \bin^n \rightarrow \bin^n\)
the distinguishing advantage of an adversary \(A\) is:
%
\begin{align*}
    \advantage{\pm \mathrm{prp}}{E}[(A)] \defeq
    {}&\left\lvert\probsub{k \sample \mathcal{K}}{A^{E_k,E_k^{-1}}\Rightarrow 1}\right.
    \\
    {}&\left. - \probsub{\pi \sample \Perm(n)}{A^{\pi,\pi^{-1}}\Rightarrow 1}\right\rvert
    \\
    \intertext{We then define}
    \advantage{\pm \mathrm{prp}}{E}[(q, t)] \defeq
    {}&\max_{A \in \mathcal{A}(q, t)} \advantage{\pm \mathrm{prp}}{E}[(A)]
\end{align*}
where $\mathcal{A}(q, t)$
is the set of all adversaries that make at most $q$ queries and take at most $t$ time.

Let $\Perm^\mathcal{T}(\mathcal{M})$
denote the set of all
tweakable length-preserving permutations
$\bm{\pi} : \mathcal{T} \times \mathcal{M} \rightarrow \mathcal{M}$
such that for all $T, M \in \mathcal{T} \times \mathcal{M}$,
$\abs{\bm{\pi}(T, M)} = \abs{M}$, and
for all $T \in \mathcal{T}$, $\bm{\pi}_{T}$ is a permutation on \(\mathcal{M}\).
In an abuse of notation
we use $\bm{\pi}^{-1}$ to refer to the function
such that $\bm{\pi}^{-1}(T, \bm{\pi}(T, M)) = M$ ie $(\bm{\pi}^{-1})_T = (\bm{\pi}_T)^{-1}$.

Per~\cite{cmc}, for a tweakable super-pseudorandom permutation
$\bm{E} : \mathcal{K} \times \mathcal{T} \times \mathcal{M} \rightarrow \mathcal{M}$
the distinguishing advantage of an adversary $A$ is:
%
\begin{align*}
    \advantage{\pm \widetilde{\mathrm{prp}}}{\bm{E}}[(A)] \defeq
    {}&\left\lvert\probsub{k \sample \mathcal{K}}{A^{\bm{E}_k,\bm{E}_k^{-1}}\Rightarrow 1}\right.
    \\
    {}&\left. - \probsub{\bm{\pi} \sample \Perm^\mathcal{T}(\mathcal{M})}
        {A^{\bm{\pi},\bm{\pi}^{-1}}\Rightarrow 1}\right\rvert
    \\
    \intertext{We then define}
    \advantage{\pm \widetilde{\mathrm{prp}}}{\bm{E}}[(q, \sigma, t)]
    \defeq {}&
    \max_{A \in \mathcal{A}(q, \sigma, t)} \advantage{\pm \widetilde{\mathrm{prp}}}{\bm{E}}[(A)]
\end{align*}
where \(\mathcal{A}(q, \sigma, t)\)
is the set of all adversaries 
that make at most \(q\) queries
and take at most \(t\) time,
such that the total number of blocks sent in all queries is
at most \(\sigma\) ie
\begin{displaymath}
    \sum_s \ceil{|T^s|/n} + \ceil{|M^s|/n} \leq \sigma
\end{displaymath}
where \(T^s, M^s\) are the tweak and message
(plaintext or ciphertext)
presented in query \(s\).

We use \(\HCTR[\pi]\) to refer to HCTR2 in which invocation
of the block cipher is replaced with invocation of the
permutation \(\pi \in \Perm(n)\).
\(\XCTR_\pi\) refers to a similar substitution.
\(\HCTR[E]\) refers to HCTR2 using the block cipher \(E\),
ie \(\HCTR[E_k]\) for \(k \sample \mathcal{K}\), while
\(\HCTR[\Perm(n)]\) refers to \(\HCTR[\pi]\)
for \(\pi \sample \Perm(n)\).

\subsection{Hash function}\label{hproperties}
In \autoref{hashspec} we defined \(\poly_h(M)\) as polynomial evaluation.
We now define \(\poly(M)\) to refer to the formal polynomial
that this implies: \(\poly(M_0 \Concat \cdots \Concat M_{l-1})
\defeq  M_0h^{l-1} \xor \cdots \xor M_{l-1}\).
While \(h + 2\) and \(2h + 1\) can be equal
in value if \(h = 1\), two formal polynomials are only equal
if every coefficient is equal; thus \(\poly(M) = \poly(M')\)
only if \(M = 0^{ln} \Concat M'\) for some \(l\) or vice versa.
We then define \(H(T, M)\) as the formal polynomial in \(h\) given
by that tweak and message,
so \(H_h(T, M)\) is then evaluation of this polynomial at \(h\).
\begin{align*}
    & H(T, M) \\
    \defeq &
    \begin{cases}
        \poly(\fromint(2\abs{T} + 2) \Concat \pad(T) \Concat M \Concat 0^n) &
        \text{if } n \text{ divides } \abs{M} \\
        \poly(\fromint(2\abs{T} + 3) \Concat \pad(T) \Concat \pad(M \Concat 1) \Concat 0^n) &
        \text{otherwise}
    \end{cases}    \\
\end{align*}

We depend on the following properties of this map 
onto formal polynomials:
\begin{itemize}
    \item The map is injective (see \autoref{injective})
    \item The constant term is always zero
    \item The polynomial is never \(0\) or \(h\)
    \item The polynomial is of degree at most
    \begin{displaymath}
        d(T, M) \defeq 1 + \ceil{\abs{T}/n} + \ceil{\abs{M}/n}
    \end{displaymath}
\end{itemize}

For any nonzero polynomial \(p(h)\)
in \(GF(2^n)\), there are at most \(\deg(p)\) values \(h\)
such that \(p(h) = 0\), and therefore
\(\probsub{h\sample{\bin^n}}{p(h) = 0} \leq \deg(p)/2^n\).
From this and the above properties,
we infer three properties of \(H_h(T, M)\):
\begin{description}
    \item[Property 1]
    For any \(T, M\) and any \(g \in \bin^n\),
    \begin{displaymath}
        \probsub{h\sample{\bin^n}}{H_h(T, M) = g} \leq d(T, M)/2^n
    \end{displaymath}
    Proof: since \(H(T, M)\) is nonzero and has
    a zero constant term,
    the polynomial \(H(T, M) \xor g\) 
    is nonzero,
    has the same degree,
    and therefore has at most \(d(T, M)\) zeroes.
    \item[Property 2] 
    For any \((T_1, M_1) \neq (T_2, M_2)\) and any \(g \in \bin^n\)
    \begin{align*}
        & \probsub{h\sample{\bin^n}}{H_h(T_1, M_1) \xor H_h(T_2, M_2) = g} \\
        \leq  & \max(d(T_1, M_1), d(T_2, M_2))/2^n
    \end{align*}
    Proof: \(H\) is injective onto polynomials
    and the constant term is zero, therefore
    \(H(T_1, M_1) \xor H(T_2, M_2) \xor g\)
    is not the zero polynomial.
    The degree is at most \(\max(d(T_1, M_1), d(T_2, M_2))\)
    and this limits the number of solutions.
    This is the almost-XOR-universal property.
    \item[Property 3]
    For any \(T, M\) and any \(g \in \bin^n\)
    \begin{displaymath}
        \probsub{h\sample{\bin^n}}{H_h(T, M) \xor h = g} \leq d(T, M)/2^n
    \end{displaymath}
    Proof: \(H(T, M)\) has a zero constant term and
    cannot be equal to the polynomial \(h\),
    so \(H(T, M) \xor g \xor h\) cannot be the zero polynomial, and
    therefore can have at most \(d(T, M)\) zeroes.
\end{description}

\subsection{H-coefficient technique}
The H-coefficient technique was introduced by Patarin in 1991~\cite{ppdes,hco}.
We highly recommend the exposition
of~\cite{hco2} Section 3,
``The H-coefficient Technique in a Nutshell'';
we here present a simpler exposition that
does not cover the technique in its full
generality but only our use of it.
Our use of the symbol \(\mathcal{T}\) and the term
``compatible'' differs slightly from~\cite{hco2}.

We wish to bound the adversary's ability to distinguish between
two ``worlds'', world X (the ``real world'') and world Y (the ``ideal world'').
Each world is a probability distribution over
deterministic oracles the adversary interacts with.

We consider only deterministic adversaries.
A randomized adversary can be considered as a random draw
from a population of deterministic adversaries, so
a bound on the advantage achievable by a deterministic
adversary bounds the whole pool and therefore
the advantage of the randomized adversary. In what follows
we consider the adversary fixed; only the world, and the
particular oracles drawn from that world, vary.

When the adversary interacts with the oracle,
a transcript \(\tau\) of queries and responses is created.
\(\Tc\) is the set of ``compatible transcripts'':
if \(\tau \in \Tc\) then for the fixed adversary,
there is some oracle
that results in its creation. For example,
since the adversary is deterministic, the first query
will always be the same; a transcript that
does not start with this query is not a compatible transcript.
For a given \(\tau \in \Tc\),
a deterministic adversary must always
return the same response; call this response \(A(\tau)\).

Let random variables \(X\) and \(Y\)
represent the distribution of transcripts
in world X and world Y respectively, so that
each transcript \(\tau\) has a probability \(\prob{X = \tau}\)
of arising in world X, and similarly \(\prob{Y = \tau}\) in world Y.
Without loss of generality,
we assume that \(\prob{A(Y) = 1} \geq \prob{A(X) = 1}\).
We further assume that \(A(\tau)\) is optimal:
\(A(\tau) = 1\)
when \(\prob{Y = \tau} > \prob{X = \tau}\) and 0 otherwise.

In \autoref{mainlemma}, we partition \(\Tc\) into \(\Tg\) and \(\Tb\),
and prove that:
\begin{itemize}
    \item \(\prob{Y = \tau} \leq \prob{X = \tau}\) for all \(\tau \in \Tg\)
    \item \(\prob{Y \in \Tb} \leq \epsilon\)
\end{itemize}
It follows that \(A(\tau) = 0\) for all \(\tau \in \Tg\),
and therefore that \(\prob{A(Y) = 1} \leq \epsilon\),
from which we bound the distinguishing advantage:
\(\prob{A(Y) = 1} - \prob{A(X) = 1} \leq \epsilon\).

With this technique, only the first proof
need consider the probability
distribution of world X at all,
and this proof need only consider good transcripts.
The bulk of the work, proving
\(\prob{Y \in \Tb} \leq \epsilon\),
involves only world Y, which is far simpler
to reason about.

\subsection{Main lemma}\label{mainlemma}
In what follows, we take world X (the ``real world'') 
to be \(\HCTR[\Perm(n)]\),
ie HCTR with all calls to the block cipher
replaced with calls to a random permutation,
and world Y (the ``ideal world'') to be \(\pm\widetilde{\mathrm{rnd}}\),
which maps every query to a random response such that
all responses of the appropriate length are equally likely;
we then use the H-coefficient technique to bound
the distinguishing advantage between them.

We use superscripts to distinguish between queries;
where we refer to \(r\), \(s\), we assume that \(r < s\).
An encryption query \((T^s, P^s)\) yields ciphertext \(C^s\)
while a decryption query \((T^s, C^s)\)
yields plaintext \(P^s\).
We forbid ``pointless queries'':
encryption queries \((T^s, P^s)\)
such that \((T^r, P^r) = (T^s, P^s)\) for some \(r < s\), 
or decryption queries \((T^s, C^s)\)
such that \((T^r, C^r) = (T^s, C^s)\) for some \(r < s\),
whether query \(r\) was an encryption or decryption query.

For each query \(s\), 
let \(m^s \defeq \ceil{\abs{P^s}/n} = \ceil{\abs{C^s}/n}\)
be the number of blocks in the response,
and let \(d^s \defeq m^s + \ceil{\abs{T^s}/n}\)
be the number of blocks in the query.
Note that \(d^s\) is the degree of the hash
function polynomial used in query \(s\)
(since all but one block of the message is hashed),
and that \(\sum_s d^s \leq \sigma\).
We give the adversary some extra information
which is included in the transcript.
In world X, this information is:
\begin{itemize}
    \item the ``leftover block'' for each query:
    where a query has plaintext/ciphertext
    that is not a multiple of the block size,
    this is the extra output from the last
    block cipher call that is not used.
    For query \(s\), this is 
    \begin{displaymath}
        D^s = \XCTR_\pi(S^s)[\abs{P^s} - n; nm^s-\abs{P^s}]
    \end{displaymath}
    \item the hash key \(h\), given after all queries are complete
    \item the mask \(L\), given after all queries are complete
\end{itemize}
In world Y, random output of the expected
length is substituted. Since the adversary can always ignore
this information, giving it to them cannot make their performance worse.

\subsubsection{Good and bad transcripts}
For \(j \in \{1 \ldots m^s-1\}\) we define \(S_j^s = S^s \xor \fromint(j)\),
the block cipher inputs used in XCTR, and \(Y_j^s\) the corresponding
outputs, so that in world X \(Y_j^s = \pi(S_j^s)\) and 
\(Y_1^s \Concat \cdots \Concat Y_{m^s-1}^s = \XCTR_\pi(S^s)[0;n(m^s -1)]\).

Given the full transcript, including \(h\) and \(L\),
we can infer all block cipher plaintexts and ciphertexts.
For each query, we know \(T\), \(P\), \(C\) and \(D\)
and so can infer
(omitting the query superscript \(s\) for readability):
\begin{align*}
    M \Concat N &= P \\
    U \Concat V &= C \\
    \MM &= M \xor H_h(T, N)\\
    \UU &= U \xor H_h(T, V)\\
    S &= \MM \xor \UU \xor L\\ 
    S_j &= S \xor \fromint(j)\\
    Y_1 \Concat \cdots \Concat Y_{m-1} &= (N \xor V) \Concat D \\
\end{align*}
This gives us multisets \(\mathcal{D}\) and \(\mathcal{R}\)
of block cipher plaintexts and ciphertexts:
\begin{align*}
    \mathcal{D} \defeq \{\fromint(0), \fromint(1)\} \uplus &
    \biguplus_s \{\MM^s, S_1^s, \ldots, S_{m^s-1}^s\}\\
    \mathcal{R} \defeq \{h, L\} \uplus &
    \biguplus_s \{\UU^s, Y_1^s, \ldots, Y_{m^s-1}^s\}
\end{align*}
We therefore infer \(\sigma_m \defeq 2 + \sum_s m^s\) block cipher
plaintexts/ciphertexts from \(\sigma_m n\) bits of query response.
A transcript is ``bad'' (\(\tau \in \Tb\))
iff any entry in \(\mathcal{D}\) or \(\mathcal{R}\)
has multiplicity greater than one,
ie if any pair of inferred plaintexts are the same, or
if any pair of inferred ciphertexts are the same.

Since responses in world Y are coin flips,
the probability of a 
particular \(\tau \in \Tc\), good or bad,
in world Y is always simply \(2^{-\sigma_m n}\).
For a transcript \(\tau \in \Tg\),
the probability in world X
is the probability of all of those plaintext/ciphertext
pairs being part of a given random permutation.
This is 
\(\prod_{i=0}^{\sigma_m -1}(1/(2^n - i))\).
Thus for all \(\tau \in \Tg\)
\(\prob{Y = \tau} \leq \prob{X = \tau}\). 

\subsubsection{Case analysis of collisions}
Next we bound \(\prob{Y \in \Tb}\).
We consider a case by case analysis of possible collisions,
in either inferred plaintexts (\(\mathcal{D}\))
or inferred ciphertexts (\(\mathcal{R}\)),
and bound the probability in world Y each case.

Responses to queries are random in world Y,
but some caution is required.
If we know the adversary's query \(s\), then conditioning on that,
we cannot treat the response to query \(r\) as uniformly random;
if the choice of later query depends on the earlier response,
knowing the later query is information about the earlier response.
However, conditioning on a query and all prior queries and responses,
we still have that \(h\), \(L\), and the
query response are uniformly random and independent,
and so we can consider them in any order.

\subfile{casetable.tex}
In most cases, the probability of a collision
between two specific blocks is bounded by \(1/2^n\).

\begin{itemize}
    \item \(h \qeq L\):
    Trivially has probability \(1/2^n\).
    In world X, this has probability 0,
    but we don't need to consider probabilities in world X
    in what follows.
    \item
    \(h \qeq Y_j^s\),
    \(L \qeq Y_j^s\),
    \(\UU^r \qeq Y_j^s\),
    \(Y_i^r \qeq Y_j^s\),
    \(Y_i^s \qeq Y_j^s\) where \(i < j\): 
    If query \(s\) is an encryption query,
    then given \(h\), \(L\), query \(s\), 
    all prior queries and responses, and
    \(C^s[0;jn]\), there is exactly one value of
    \(C^s[jn;n]\) that results in the equation holding.
    If \(s\) is a decryption query, the same reasoning holds
    with \(P^s\), \(C^s\) swapped.
    \item 
    \(\UU^s \qeq Y_j^s\):
    If query \(s\) is a decryption query,
    the exact argument above applies.
    If it is an encryption query,
    then given \(h\), \(L\), \(T^s\), \(P^s\),
    and \(V^s\), there is exactly
    one value of \(U^s\) that results
    in the equation holding.
    \item 
    \(\fromint(0) \qeq S_j^s\),
    \(\fromint(1) \qeq S_j^s\),
    \(\MM^r \qeq S_j^s\),
    \(S_i^r \qeq S_j^s\):
    If query \(s\) is an encryption query,
    then given \(h\), \(L\), \(T^s\),
    \(P^s\), \(V^s\)
    and all prior queries and responses,
    there is exactly one response value \(U^s\)
    that results in the equation holding.
    For a decryption query, 
    given \(h\), \(L\), \(T^s\),
    \(C^s\), \(N^s\)
    and all prior queries and responses,
    there is exactly one response value \(M^s\)
    that results in the equation holding.
    \item
    \(\MM^s \qeq S_j^s\),
    \(S_i^r \qeq \MM^s\),
    \(L \qeq \UU^s\):
    Given \(h\) and all queries and responses,
    there is exactly one value of \(L\)
    which causes the equation to hold.
\end{itemize}

In two cases, a collision is impossible.

\begin{itemize}
    \item \(\fromint(0) \qeq \fromint(1)\): 
    Trivially impossible.
    \item 
    \(S_i^s \qeq S_j^s\) where \(i < j\):
    This is impossible; 
    \(S_i^s \xor S_j^s = \fromint(i) \xor \fromint(j)\).
\end{itemize}

There are a handful of cases where the probability may
be greater than \(1/2^n\).
Considering first collisions with \(\MM^s\) where
query \(s\) is an encryption query:

\begin{itemize}
    \item \(\MM^r \qeq \MM^s\):
    This holds if \(M^r \xor H_h(T^r, N^r) = M^s \xor H_h(T^s, N^s)\);
    by hash function property 2, this holds with probability at most
    \(\max(d^r, d^s)/2^n\).
    \item \(\fromint(0) \qeq \MM^s\):
    This holds if \(\fromint(0) = M^s \xor H_h(T^s, N^s)\);
    by hash function property 1, this holds with probability at most
    \(d^s/2^n\).
    \item \(\fromint(1) \qeq \MM^s\):
    As above.
\end{itemize}

In each case, if query \(s\) is a decryption query,
then given \(h\), \(T^s\), \(C^s\), \(N^s\),
and all prior queries and responses,
all values of \(M^s\) are equally likely 
and a single value causes the equation to hold,
for a probability of \(1/2^n\).

Similarly, considering collisions with \(\UU^s\) where
query \(s\) is a decryption query:

\begin{itemize}
    \item \(\UU^r \qeq \UU^s\): 
    This holds if \(U^r \xor H_h(T^r, V^r) = U^s \xor H_h(T^s, V^s)\);
    by hash function property 2, this holds with probability at most
    \(\max(d^r, d^s)/2^n\).
    \item \(Y_i^r \qeq \UU^s\):
    This holds if \(Y_i^r = U^s \xor H_h(T^s, V^s)\);
    by hash function property 1, this holds with probability at most
    \(d^s/2^n\).
    \item \(h \qeq \UU^s\):
    This holds if \(h = U^s \xor H_h(T^s, V^s)\);
    by hash function property 3, this holds with probability at most
    \(d^s/2^n\).
\end{itemize}

As above, if query \(s\) is an encryption query,
then given \(h\), \(T^s\), \(P^s\), \(V^s\),
and all prior queries and responses,
all values of \(U^s\) are equally likely
and a single value causes the equation to hold,
for a probability of \(1/2^n\).

\autoref{domaincollision} illustrates the various cases
we consider for inferred block cipher plaintext collisions.
Rows represent the terms
on the left hand side of the collision, while
columns represent the terms on the right; 
for example, the top left box represents
\(\fromint(0) \qeq \fromint(1)\). Where a square is left blank
it is either because it represents
comparing a term to itself (eg \(\MM^s \qeq \MM^s\))
or because it represents something that
is already handled elsewhere
(eg considering \(\fromint(1) \qeq \MM^s\)
handles the \(\MM^r \qeq \fromint(1)\) case).
A square is colored red
and marked \(0\) if the
probability of a particular instance
if that kind is zero, grey
and marked \(1\) if
the probability is always \(1/2^n\),
and green if the probability may be
greater than \(1/2^n\) and depends
on the number of solutions to a
particular polynomial;
\(d^s\) when there are at most \(d^s\) solutions,
\(\max\) where there are at most
\(\max(d^r, d^s)\) solutions.
Even where a square is green,
if query \(s\) is a decryption query,
the probability of a particular collision of
that kind is \(1/2^n\).
Where a rectangle covers
multiple squares, a single argument
covering all those cases is presented.
\autoref{rangecollision} covers
block cipher ciphertext collisions; in this case,
it is only decryption queries where
probabilities may be above \(1/2^n\).

\subsubsection{Summing collision bounds}
Given that most pairs have a probability of
colliding of \(1/2^n\), 
to establish an upper bound that any pair
will collide across all of these cases,
we start with the bound that would result
if all pairs had a bound of \(1/2^n\),
and then apply a correction for the ones that don't.

For example,
to bound the probability an encryption query \(s\)
has some collision with the fixed values 
\(\fromint(0)\), \(\fromint(1)\), \(h\) and \(L\)
we observe first that
there are two blocks in the fixed values
and \(m^s\) blocks in query \(s\), so there are
\(2m^s\) pairs of blocks across the two,
and \(4m^s\) opportunities for a collision, 
considering both plaintext and ciphertext.
If all pairs had collision probability \(1/2^n\),
then the overall collision probability bound
would be \(4m^s/2^n\). However, there are
two exceptions: the pairs
\(\fromint(0) \qeq \MM^s\) and
\(\fromint(1) \qeq \MM^s\). In each of these
cases the probability bound is not \(1/2^n\) but
\(d^s/2^n\), We therefore apply a correction
of \(2(d^s - 1)\) to get a final probability bound of
\begin{displaymath}
    \frac{4m^s + 2(d^s - 1)}{2^n}
\end{displaymath}

Similarly, the correction for a decryption query is
\(d^s - 1\) and therefore  the probability 
is bounded above by
\begin{displaymath}
    \frac{4m^s + d^s -1}{2^n}
\end{displaymath}
The larger of the two correction formulas is
the first one, so we use that for our overall bound.
Across all queries, the total
correction will be
\begin{align*}
    &\sum_s 2(d^s - 1) \\
    \leq & 2(\sigma - q)
\end{align*}

For a collision of two blocks within query \(s\)
the correction formula is negative:
\(S_i^s \qeq S_j^s\) is an impossible collision, 
so we subtract the number of such blocks:
\(-\binom{m^s -1}{2}\). However we have no good way
to impose a useful upper bound on the negative sum
\(\sum_s-\binom{m^s -1}{2}\) so we use the
trivial upper bound of 0.

Where an encryption query \(s\)
may collide with query \(r\), the correction is 
\(\max(d^r, d^s) -1\)
(because of \(\MM^r \qeq \MM^s\)), whereas for a decryption query
it is \(\max(d^r, d^s) -1 + (m^r -1 )(d^s -1)\)
(because of \(\UU^r \qeq \UU^s\) and \(Y_i^r \qeq \UU^s\)).

Taking the max of these formulas and summing across
all queries gives us a total correction of
\begin{align*}
    &\sum_{r < s} \max(d^r, d^s) -1 + (m^r -1 )(d^s -1)\\
    \leq & \sum_{r < s} d^r + d^s -1 + (m^r -1 )(d^s -1)\\
    \leq & (q-1)\sigma - \binom{q}{2} + \sum_{r < s} (m^r -1 )(d^s -1) \\
    \leq & (q-1)\sigma - \binom{q}{2} + \sum_{r < s} (d^r -1)(d^s -1) \\
    \leq & (q-1)\sigma - \binom{q}{2} + \binom{\sigma - q}{2} \\
   \leq & (q-1)\sigma + \binom{\sigma}{2} \\
\end{align*}

The correction for collision between fixed values
is \(-1\), reflecting the impossibility of the collision
\(\fromint(0) \qeq \fromint(1)\).

Thus our total correction is
\(2(\sigma - q) + (q-1)\sigma + \binom{\sigma}{2} -1\)
and the number of pairs of blocks is \(\binom{\sigma_m}{2}\), 
giving an upper bound
on the probability of a bad transcript of

\begin{align*}
    & \left.\left(2\binom{\sigma_m}{2} + 2(\sigma - q) + (q-1)\sigma + \binom{\sigma}{2} -1\right)\middle/2^n\right. \\
    \leq & \left.\left(2\binom{\sigma + 2}{2} + 2(\sigma - q) + (q-1)\sigma + \binom{\sigma}{2} -1\right)\middle/2^n\right. \\
    = & \left.\left(2\left(\binom{\sigma}{2} + 2\sigma + 1\right) + 2(\sigma - q) + (q-1)\sigma + \binom{\sigma}{2} -1\right)\middle/2^n\right. \\
    = & \left.\left(3\sigma(\sigma - 1)/2 + q\sigma + 5\sigma - 2q + 1\right)\middle/2^n\right. \\
    \leq & \left.\left(3\sigma^2 + 2q\sigma + 7\sigma + 2\right)\middle/2^{n+1}\right. \\
\end{align*}

Applying the H-coefficient technique, we therefore conclude that
\begin{align*}
    & \advantage{\pm\widetilde{\mathrm{rnd}}}{\HCTR[\Perm(n)]}[(q, \sigma, t)] \\
    \leq & \prob{Y \in \Tb} \\
    \leq & \left.\left(3\sigma^2 + 2q\sigma + 7\sigma + 2\right)\middle/2^{n+1}\right.
\end{align*}

\subsection{Security bound}
By a standard substitution argument~\cite{cbcsec,concrete} we have that
\begin{displaymath}
    \advantage{\HCTR[\Perm(n)]}{\HCTR[E]}[(q, \sigma, t)]
    \leq \advantage{\pm \mathrm{prp}}{E}[(\sigma + 2, t + \sigma t')]
\end{displaymath}
where \(t'\) is a small constant
representing the per-block cost of simulating HCTR2, and
\(\sigma + 2\) bounds the number of block cipher calls made by the simulator.
Halevi and Rogaway's PRP-RND lemma
\cite[Appendix C, Lemma 6]{cmc} tells us that
\begin{displaymath}
    \advantage{\pm \widetilde{\mathrm{prp}}}{\pm\widetilde{\mathrm{rnd}}}[(q, \sigma, t)] 
    \leq \left.\binom{q}{2}\middle/2^n\right.
    \leq q^2/2^{n+1}
\end{displaymath}
Putting these together with our main lemma, we have shown
\begin{align*}
    &\advantage{\pm \widetilde{\mathrm{prp}}}{\HCTR[E]}[(q, \sigma, t)] \\
    \leq & \quad \advantage{\pm \mathrm{prp}}{E}[(\sigma + 2, t + \sigma t')] \\
    &+ \left.\left(3\sigma^2 + 2q\sigma + q^2 + 7\sigma + 2\right)\middle/2^{n+1}\right. \\
\end{align*}
\end{document}
