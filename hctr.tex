% Copyright 2021 Google LLC
%
% Use of this source code is governed by an MIT-style
% license that can be found in the LICENSE file or at
% https://opensource.org/licenses/MIT.

%!TeX spellcheck = en-US

\documentclass[letterpaper,11pt]{article}

\usepackage{floatrow}
\usepackage{algpseudocode}
\usepackage{amsmath}
\usepackage[style=alphabetic,backend=biber,alldates=ymd]{biblatex}
\usepackage{bm}
\usepackage[logic,probability,advantage,adversary,landau,sets,operators]{cryptocode}
\usepackage{hyperref}
\usepackage{tikz}

\usetikzlibrary{groupops}

\addbibresource{bib.bib}

\newcommand*{\Concat}{\Vert}
\newcommand*{\defeq}{\stackrel{\text{def}}{=}}
\newcommand*{\MM}{\mathit{MM}}
\newcommand*{\VV}{\mathit{VV}}

\DeclareMathOperator{\fromint}{bin}
\DeclareMathOperator{\GF}{GF}
\DeclareMathOperator{\HCTR}{HCTR2}
\DeclareMathOperator{\pad}{pad}
\DeclareMathOperator{\Perm}{Perm}
\DeclareMathOperator{\poly}{poly}
\DeclareMathOperator{\rnd}{rnd}
\DeclareMathOperator{\XCTR}{XCTR}

\title{HCTR2}

\begin{document}
\maketitle

\begin{abstract}
\end{abstract}

\section{Introduction}
The construction HCTR\cite{hctr} is among the most efficient for 
tweakable length-preserving encryption from a block cipher, using
a single block cipher invocation and two \(GF(2^n)\) multiplies
per block. Unfortunately, as presented it has two serious flaws.
The first, observed in \cite{kumarhctr}, is that the hash function
is not \(\epsilon\)-almost-XOR-universal\cite{eadu} as claimed.
The second is that an error in the proof presented in \cite{hctrquad}
invalidates the claimed quadratic security bound, leaving
only an unsatisfactory cubic bound. 

This paper proposes a new revision, HCTR2, fixing these issues.
We know of no patents affecting use of HCTR2.
\cite{adiantum} includes a detailed history of length-preserving encryption.
We begin with the specification and proof for HCTR2, laying
the groundwork for describing the flaws with HCTR (\autoref{hctrflaws}),
after which we discuss HCTR2 design decisions
and report on its implementation on x86-64 and ARM64.

\section{Specification}
\begin{figure}
    \input{hctr2fig.tex}
    \caption{HCTR2}\label{hctr2fig}
\end{figure}
\begin{figure}
    \begin{floatrow}
        \ffigbox{
            \begin{algorithmic}[0]
                \Procedure{\(HCTR2_{k, T}\)}{$P$}
                \State $h \gets E_k(0^n)$
                \State $L \gets E_k(10^{n-1})$
                \State $M \Concat N \gets P$, $|M| = n$
                \State $\MM \gets M \xor H_h(T, N)$
                \State $\VV \gets E_k(\MM)$
                \State $S \gets \MM \xor \VV \xor L$
                \State $W \gets N \xor \XCTR_k(S)[0;\abs{N}]$
                \State $V \gets \VV \xor H_h(T, Z)$
                \State $C \gets V \Concat W$
                \State \textbf{return} $C$
                \EndProcedure
            \end{algorithmic}
        }{
            \caption{HCTR2 encryption}\label{pseudocode}
        }
        \ffigbox{
            \begin{algorithmic}[0]
                \Procedure{\(HCTR2_{k, T}^{-1}\)}{$C$}
                \State $h \gets E_k(0^n)$
                \State $L \gets E_k(10^{n-1})$
                \State $V \Concat W \gets C$, $|V| = n$
                \State $\VV \gets V \xor H_h(T, W)$
                \State $\MM \gets E_k^{-1}(\VV)$
                \State $S \gets \MM \xor \VV \xor L$
                \State $N \gets W \xor \XCTR_k(S)[0;\abs{W}]$
                \State $M \gets \MM \xor H_h(T, N)$
                \State $P \gets M \Concat N$
                \State \textbf{return} $P$
                \EndProcedure
            \end{algorithmic}
        }{
            \caption{HCTR2 decryption}
        }
    \end{floatrow}
\end{figure}
\subsection{Notation}
Subscripts may denote partial application; if we define $f: A \times B \rightarrow C$ and
$a \in A$ then $f_a: B \rightarrow C$, and if $f_a^{-1}$ exists then $f_a^{-1}(f_a(b)) = b$.
\begin{itemize}
    \item $\abs{X}$: length of $X \in \bin^{*}$ in bits
    \item $\lambda$: the empty string $\abs{\lambda} = 0$
    \item $\Concat$: bitstring concatenation
    \item \(\xor\): bitwise XOR
    \item $Y[a;l]$: the subsequence of $Y$ of length $l$ starting at the 0-based index $a$
    \item $\fromint_l: \{0 \ldots 2^l-1\} \rightarrow \bin^l$:
    little-endian conversion of integers to binary
    \item \(n\): block size in bits; we assume \(n\) is even
    \item $\pad_n(X) = X \Concat 0^v$
    where $v$ is the least integer $\geq 0$ such that $n$ divides $\abs{X} + v$
    \item \(E: \mathcal{K} \times \bin^n \rightarrow \bin^n\): 
    \(n\)-bit block cipher with keyspace \(\mathcal{K}\);
    our concrete proposal uses AES, so \(n=128\) and \(\mathcal{K}\) is
    \(\bin^{128}\), \(\bin^{192}\), or \(\bin^{256}\)
    \item \(\mathcal{T}\): the set of permissible tweaks
    \(\mathcal{T} = \bigcup_{i \in \{0\ldots2^{n-1}-1\}}\bin^i\)
    \item \(\mathcal{M}\): the set of permissible messages
    \(\mathcal{M} = \bigcup_{i \in \{n\ldots2^{n-1}-1\}}\bin^i\)
\end{itemize}
We map bytes to bitstrings with \(\fromint_8\).

\subsection{Polynomial hash function}
We interpret \(n\)-bit blocks as little-endian field elements of \(\GF(2^n)\),
so \(0010^{n-3}\) is interpreted as the element \(x^2\).
Where \(n=128\) we reduce by
\(1 + x + x^2 + x^7 + x^{128}\). Then let
\begin{displaymath}
    \poly(M_0 \Concat M_1 \Concat \cdots \Concat M_{l-2} \Concat M_{l-1})
\end{displaymath}
refer to the polynomial
\begin{displaymath}
    p(h) = M_0h^{l-1} \xor M_1h^{l-2} \xor \cdots \xor M_{l-2}h \xor M_{l-1}
\end{displaymath}

We define a polynomial for tweak \(T\) and message \(M\). Where \(n\) divides
\(\abs{M}\) this is
\begin{displaymath}
    H(T, M) = \poly(\fromint_{n}(2\abs{T} + 2) \Concat \pad_n(T) \Concat M \Concat 0^n)
\end{displaymath}
in other instances this is
\begin{displaymath}
    H(T, M) = \poly(\fromint_{n}(2\abs{T} + 3) \Concat \pad_n(T) \Concat \pad_n(M \Concat 1) \Concat 0^n)
\end{displaymath}

We then define our hash function \(H_h(T, M)\) as evaluation
of the polynomial \(H(T, M)\) at \(h\) for key \(h \in \bin^n\).

\subsection{XCTR mode}

HCTR and HCTR2 use an unusual mode of stream encryption.
\cite{hctr,hctrquad} note the differences between this mode and CTR mode,
but use the same name to refer to it; for the avoidance of ambiguity
we name this mode \emph{XCTR mode}, and define:
\begin{displaymath}
    \XCTR_k(S) = E_k(S \xor \fromint(1)) \Concat E_k(S \xor \fromint(2)) \Concat E_k(S \xor \fromint(3)) \Concat \cdots
\end{displaymath}
thus generating the first \(m\) bits \(\XCTR_k(S)[0; m]\) takes \(\ceil{m/n}\) block cipher calls.

\subsection{HCTR2 encryption}

From these definitions, HCTR2 is as defined in \autoref{pseudocode}.
Note that what is referred to in \cite{hctr,hctrquad} as \(C, \mathit{CC}, D\)
we refer to as \(V, VV, W\)
so that we can use \(P, C\) to refer to plaintext and ciphertext.

\section{Security of HCTR2}

\subsection{Definitions}

The block cipher
$E$
must be a super-pseudorandom permutation~\cite{concsym}:
%
\begin{align*}
    \advantage{\pm \mathrm{prp}}{E}[(A)] \defeq
    {}&\left\lvert\probsub{k \sample \mathcal{K}}{A^{E_k,E_k^{-1}}\Rightarrow 1}\right.
    \\
    {}&\left. - \probsub{\pi \sample \Perm(n)}{A^{\pi,\pi^{-1}}\Rightarrow 1}\right\rvert
    \\
    \advantage{\pm \mathrm{prp}}{E}[(q, t)] \defeq
    {}&\max_{A \in \mathcal{A}(q, t)} \advantage{\pm \mathrm{prp}}{E}[(A)]
\end{align*}
%
where $A$ is an adversary,
$\Perm(S)$ denotes the set of all permutations on a set $S$,
$\Perm(n)$ is short for $\Perm(\bin^n)$
and
$\mathcal{A}(q, t)$
is the set of all adversaries that make at most $q$ queries and take at most $t$ time.

Let $\Perm^\mathcal{T}(\mathcal{M})$
denote the set of all
tweakable length-preserving permutations
$\bm{\pi} : \mathcal{T} \times \mathcal{M} \rightarrow \mathcal{M}$
such that for all $T, M \in \mathcal{T} \times \mathcal{M}$,
$\abs{\bm{\pi}(T, M)} = \abs{M}$, and
for all $T \in \mathcal{T}$, $\bm{\pi}_{T}$ is a bijection on \(\mathcal{M}\).
In an abuse of notation
we use $\bm{\pi}^{-1}$ to refer to the function
such that $\bm{\pi}^{-1}(T, \bm{\pi}(T, M)) = M$ ie $(\bm{\pi}^{-1})_T = (\bm{\pi}_T)^{-1}$.

Per~\cite{cmc}, for a tweakable super-pseudorandom permutation
$\bm{E} : \mathcal{K} \times \mathcal{T} \times \mathcal{M} \rightarrow \mathcal{M}$
the distinguishing advantage of an adversary $A$ is:
%
\begin{align*}
    \advantage{\pm \widetilde{\mathrm{prp}}}{\bm{E}}[(A)] \defeq
    {}&\left\lvert\probsub{K \sample \mathcal{K}}{A^{\bm{E}_k,\bm{E}_k^{-1}}\Rightarrow 1}\right.
    \\
    {}&\left. - \probsub{\bm{\pi} \sample \Perm^\mathcal{T}(\mathcal{M})}
        {A^{\bm{\pi},\bm{\pi}^{-1}}\Rightarrow 1}\right\rvert
    \\
    \intertext{We then define}
    \advantage{\pm \widetilde{\mathrm{prp}}}{\bm{E}}[(\sigma, t)]
    \defeq {}&
    \max_{A \in \mathcal{A}(\sigma, t)} \advantage{\pm \widetilde{\mathrm{prp}}}{\bm{E}}[(A)]
\end{align*}
where \(\mathcal{A}(\sigma, t)\)
is the set of all adversaries taking at most \(t\) time,
such that the total of all blocks sent in queries is
at most \(\sigma\) ie
\begin{displaymath}
    \sum_i \ceil{|T^i|/n} + \ceil{|M^i|/n} \leq \sigma
\end{displaymath}
and \(T^i, M^i\) are the tweak and message
(plaintext or ciphertext)
presented in query \(i\).

We use \(\HCTR[\pi]\) to refer to HCTR2 in which invocation
of the block cipher is replaced with invocation of the
permutation \(\pi \in \Perm(n)\); thus for key
\(k \in \mathcal{K}\) regular HCTR2 is \(\HCTR[E_k]\).
\(\XCTR_\pi\) refers to a similar substitution.
\(\HCTR[E]\) refers to regular HCTR2,
ie \(\HCTR[E_k]\) for \(k \sample \mathcal{K}\), while
\(\HCTR[\Perm(n)]\) refers to \(\HCTR[\pi]\)
for \(\pi \sample \Perm(n)\).

\subsection{Hash function}
For any nonzero polynomial \(p(h)\)
in \(GF(2^n)\) 
of degree \(d\), there are at most \(d\) values \(h\)
such that \(p(h) = 0\), and therefore
\(\probsub{h\sample{\bin^n}}{p(h) = 0} \leq d/2^n\).
We depend on the following properties of the map from 
\(H(T, M)\) to polynomials:
\begin{itemize}
    \item The map is injective
    \item The first term of \(H(T, M)\) is always nonzero,
    and so the polynomial is of degree exactly
    \begin{displaymath}
        d(T, M) = 1 + \ceil{\abs{T}/n} + \ceil{\abs{M}/n}
    \end{displaymath}
    \item The constant term is always zero
    \item The polynomial is never \(h\)
\end{itemize}
Note that these are all considerations about the polynomial,
not about the value \(H_h(T, M)\);
for example we may have \(H_h(T, M) = h\) for some values of \(h\).

From this we infer three properties of \(H_h(T, M)\):
\begin{description}
    \item[Property 1]
    For any \(T, M\) and any \(g \in \bin^n\),
    \begin{displaymath}
        \probsub{h\sample{\bin^n}}{H_h(T, M) = g} \leq d(T, M)/2^n
    \end{displaymath}
    Proof: since \(d(T, M) \geq 1\)
    the polynomial \(H(T, M) \xor g\) has the same degree,
    is nonzero,
    and therefore has at most that many zeroes.
    \item[Property 2] 
    For any \((T_1, M_1) \neq (T_2, M_2)\) and any \(g \in \bin^n\)
    \begin{align*}
        & \probsub{h\sample{\bin^n}}{H_h(T_1, M_1) \xor H_h(T_2, M_2) = g} \\
        \leq  & \max(d(T_1, M_1), d(T_2, M_2))/2^n
    \end{align*}
    Proof: \(H\) is injective onto polynomials
    and the constant term is zero, therefore
    \(H(T_1, M_1) \xor H(T_2, M_2) \xor g\)
    is not the zero polynomial.
    The degree is at most \(\max(d(T_1, M_1), d(T_2, M_2))\)
    and this limits the number of solutions.
    This shows that the hash function is
    \(\epsilon\)-almost-XOR-universal.
    \item[Property 3]
    For any \(T, M\) and any \(g \in \bin^n\)
    \begin{displaymath}
        \probsub{h\sample{\bin^n}}{H_h(T, M) \xor h = g} \leq d(T, M)/2^n
    \end{displaymath}
    Proof: \(H(T, M)\) has a zero constant term and
    cannot be equal to the polynomial \(p(h) = h\),
    so \(H(T, M) \xor g \xor h\) cannot be the zero polynomial, and
    therefore can have at most \(d(T, M)\) zeroes.
\end{description}

\subsection{H-coefficient technique}
The H-coefficient technique was introduced by Patarin in 1991~\cite{ppdes,hco}.
We highly recommend the exposition of
\cite{hco2} Section 3,
``The H-coefficient Technique in a Nutshell'';
our use of the technique is simple enough
that a simpler exposition is possible.

We wish to bound the adversary's ability to distinguish between
two ``worlds'', world X (the ``real world'') and world Y (the ``ideal world'').
Each world is a probability distribution over oracles the adversary
interacts with.

We consider only deterministic adversaries.
A randomized adversary can be considered as a random draw
from a population of deterministic adversaries, so
a bound on the advantage achievable by a deterministic
adversary bounds the whole pool and therefore
the advantage of the randomized adversary. In what follows
we consider the adversary fixed; only the world, and the
particular oracles drawn from that world, vary.

When the adversary interacts with the world,
a transcript of queries and responses is created.
Each transcript \(\tau\) has a probability \(\prob{X = \tau}\)
of arising in world X, and similarly \(\prob{Y = \tau}\) in world Y.
For a given transcript, a deterministic adversary must always
return the same response. 



\subsection{Main lemma} 
Let world X (the ``real world'') be \(\HCTR[\Perm(n)]\),
which is HCTR with all calls to the block cipher
replaced with calls to a random permutation.
Let world Y (the ``ideal world'') be \(\pm\rnd\),
in which all queries are answered randomly.
We forbid ``pointless queries'':
encryption queries \(P, T\)
which are identical to previous encryption queries
or for which the value \(P\) was returned from a prior
decryption  query \(C, T\), or
decryption queries \(C, T\)
which are identical to previous decryption queries
or for which the value \(C\) was returned from a prior
encryption  query \(P, T\).

After all queries are complete, we give the attacker
extra information
which is included in the transcript;
this cannot make
their performance worse. In the ``real world'', 
this information is:
\begin{itemize}
    \item the hash key \(h\)
    \item the ``leftover block'' for each query:
    where a query has plaintext/ciphertext
    that is not a multiple of the block size,
    this is the extra output from the last
    blockcipher call that is not used.
    For query \(i\) this is 
    \begin{displaymath}
        \XCTR(S^i)[\abs{P}; n\ceil{\abs{P}/n}-\abs{P}]
    \end{displaymath}
\end{itemize}
In the ``ideal world'', random output of the expected
length is substituted.

\subsection{Security bound}

\section{HCTR issues}\label{hctrflaws}
\subsection{Hash function}
HCTR uses a hash function based on the polynomial
\begin{displaymath}
    H(X) = \poly(\pad_n(X) \Concat \fromint_{n}(X) \Concat 0^n)
\end{displaymath}
Because it assumes a fixed-length tweak it simply sets \(X = M \Concat T\).
However, HCTR requires that the resulting polynomial be nonzero
even when \(X = \lambda\), so as a special case they define
\(H(\lambda) = h\).

Unfortunately, as \cite{kumarhctr} observes this is no longer
an injective map from \(X\) - we also have \(H(0) = h\). This
straightforwardly leads to an attack in which two encryption queries
are presented, one of a block width, and the second extending
the first with a single zero (and assuming a zero length tweak).

\subsection{Security bound}
\cite{hctr} was initially presented with a security bound cubic
in the total size of all queries combined.  This is a little low
for comfort; if a 128-bit blockcipher is used, it suggests a
distinguisher can be effective given tens of terabytes of queries,
which can quickly be reached over a fast link. 

\cite{hctrquad} presents a much more satisfactory quadratic bound.
However, it appears the proof of that bound has a critical error.

While presented in a different way, this proof is very similar
to that of this paper: in the game RAND2, all queries get random
responses, the block cipher inputs are inferred, and a collision
in either the domain or range of the block cipher
sets the ``bad'' flag.



Equation 17 is based on a correct belief that the assertion that
the inferred ciphertext
of the block cipher lookup for the first block in query \(s'\) is
equal to the inferred ciphertext for subsequent block \(i\) in
query \(s\)
gives us a nonzero polynomial in \(h\)

assertion that in game RAND2, 
\(\prob{\mathit{CC}^{s'} = Y_i^s} \leq (m^{s'} + t)/2^n\) - in
other words, that the probability that


grows with the length of query \(s'\)
, from
which a quadra

We see no easy fix to the proof
without modifying the mode itself.

\section{Design of HCTR2}
\begin{itemize}
    \item When hashing, we represent the length as \(\abs{X} + 1\)
    \item We mix in an extra constant in the generation of \(S\) as discussed above.
    \item we keep the XCTR mode to avoid unnecessary change and beceause it has efficiency
    advantages, though we no longer need it for our proof.
    \item We allow a variable-length tweak; copying GHASH\cite{gcm}, 
    we include the length of message and tweak in the last block. 
    \item We process the length and tweak first as a small optimization
    \item We generate \(h \gets E_k(0)\)---note that the security of doing so is very sensitive to our other hashing choices
    \item We specify endianness and the like so that implementations can be interoperable
    \item We provide a sample implementation and test vectors
    \item We rename some variables in our exposition and proof to allow some more standard usage
    \item We present a new proof, based on the H-coefficient technique, with a slightly tighter bound.
\end{itemize}

\section{Implementation}



\printbibliography[heading=bibintoc]

\end{document}
