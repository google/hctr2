% Copyright 2021 Google LLC
%
% Use of this source code is governed by an MIT-style
% license that can be found in the LICENSE file or at
% https://opensource.org/licenses/MIT.

%!TeX spellcheck = en-US

\documentclass[letterpaper,11pt]{article}

\usepackage{floatrow}
\usepackage{algpseudocode}
\usepackage{amsmath}
\usepackage[style=alphabetic,backend=biber,alldates=ymd]{biblatex}
\usepackage[logic,probability,advantage,adversary,landau,sets,operators]{cryptocode}
\usepackage{hyperref}
\usepackage{tikz}

\usetikzlibrary{groupops}

\addbibresource{bib.bib}

\newcommand*{\parintro}[1]{\textbf{#1}:}
\newcommand*{\Concat}{\Vert}
\newcommand*{\MM}{\mathit{MM}}
\newcommand*{\YY}{\mathit{YY}}

\DeclareMathOperator{\fromint}{bin}
\DeclareMathOperator{\GF}{GF}
\DeclareMathOperator{\HCTR}{HCTR2}
\DeclareMathOperator{\pad}{pad}
\DeclareMathOperator{\Perm}{Perm}
\DeclareMathOperator{\Poly}{Poly}
\DeclareMathOperator{\rnd}{rnd}
\DeclareMathOperator{\XCTR}{XCTR}

\title{HCTR2}

\begin{document}
\maketitle

\begin{abstract}
\end{abstract}

\section{Introduction}
Changes from HCTR
\begin{itemize}
    \item When hashing, we write \(\abs{X} + 1\) in the last block, to fix the issue discussed above
    \item We allow a variable-length tweak; copying GHASH\cite{gcm}, 
    we include the length of message and tweak in the last block. 
    \item We process the tweak first as a small optimization
    \item We generate \(h \gets E_k(0)\)---note that the security of doing so is very sensitive to our other hashing choices
    \item We specify endianness and the like so that implementations can be interoperable
    \item We provide a sample implementation and test vectors
    \item We rename some variables in our exposition and proof to allow some more standard usage
    \item We present a new proof, based on the H-coefficient technique, with a slightly tighter bound.
\end{itemize}

we don't know of any patents etc

\section{Specification}
\begin{figure}
    \input{hctr2fig.tex}
    \caption{HCTR2}\label{hctr2fig}
\end{figure}
\begin{figure}
    \begin{floatrow}
        \ffigbox{
            \begin{algorithmic}[0]
                \Procedure{\(HCTR2_{k, T}\)}{$P$}
                \State $h \gets E_k(0^n)$
                \State $M \Concat N \gets P$, $|M| = n$
                \State $\MM \gets M \xor H_h(T, N)$
                \State $\YY \gets E_k(\MM)$
                \State $S \gets \MM \xor \YY$
                \State $Z \gets N \xor \XCTR_k(S)[0;\abs{N}]$
                \State $Y \gets \YY \xor H_h(T, Z)$
                \State $C \gets Y \Concat Z$
                \State \textbf{return} $C$
                \EndProcedure
            \end{algorithmic}
        }{
            \caption{HCTR2 encryption}\label{pseudocode}
        }
        \ffigbox{
            \begin{algorithmic}[0]
                \Procedure{\(HCTR2_{k, T}^{-1}\)}{$C$}
                \State $h \gets E_k(0^n)$
                \State $Y \Concat Z \gets C$, $|Y| = n$
                \State $\YY \gets Y \xor H_h(T, Z)$
                \State $\MM \gets E_k^{-1}(\YY)$
                \State $S \gets \MM \xor \YY$
                \State $N \gets Z \xor \XCTR_k(S)[0;\abs{Z}]$
                \State $M \gets \MM \xor H_h(T, N)$
                \State $P \gets M \Concat N$
                \State \textbf{return} $P$
                \EndProcedure
            \end{algorithmic}
        }{\caption{HCTR2 decryption}}
    \end{floatrow}
\end{figure}
\subsection{Notation}
Subscripts may denote partial application; if we define $f: A \times B \rightarrow C$ and
$a \in A$ then $f_a: B \rightarrow C$, and if $f_a^{-1}$ exists then $f_a^{-1}(f_a(b)) = b$.
\begin{itemize}
    \item $\abs{X}$: length of $X \in \bin^{*}$ in bits
    \item $\lambda$: the empty string $\abs{\lambda} = 0$
    \item $\Concat$: bitstring concatenation
    \item $Y[a;l]$: the subsequence of $Y$ of length $l$ starting at the 0-based index $a$.
    \item $\pad_l(X) = X \Concat 0^v$
    where $v$ is the least integer $\geq 0$ such that $l$ divides $\abs{X} + v$
    \item $\fromint_l: \{0 \ldots 2^l-1\} \rightarrow \bin^l$: little-endian integer representation.
    \item \(n\): block size in bits. We assume \(n\) is even.
    \item \(E: \mathcal{K} \times \bin^n \rightarrow \bin^n\): 
    \(n\)-bit block cipher with keyspace \(\mathcal{K}\);
    our concrete proposal uses AES, so \(n=128\) and \(\mathcal{K}\) is
    \(\bin^{128}\), \(\bin^{192}\), or \(\bin^{256}\). 
    \item \(\xor\): bitwise XOR
\end{itemize}
We map bytes to bitstrings with \(\fromint_8\).

\subsection{Polynomial hash function}

Let \(\Poly(M_0 \Concat M_1 \Concat \cdots \Concat M_{l-2} \Concat M_{l-1})\)
refer to the polynomial
\(M_0x^{l-1} \xor M_1x^{l-2} \xor \cdots \xor M_{l-2}x \xor M_{l-1}\)
where each \(n\)-bit \(M_i\) is interpreted as a \(\GF(2^n)\)
field element in a little-endian fashion
(so \(0010^{n-3}\) is interpreted as the element \(x^2\)).
Where \(n=128\) we reduce by the polynomial
\(1 + x + x^2 + x^7 + x^{128}\).

For tweak, message \(\abs{T}, \abs{N} < 2^{n/2} -1\) we define a polynomial
\begin{displaymath}
    H(T, M) = \Poly(\pad_n(T) \Concat \pad_n(M) \Concat \fromint_{n/2}(\abs{T} + 1) \Concat \fromint_{n/2}(\abs{M} + 1) \Concat 0^n)
\end{displaymath}
which is of degree at most
\(d(T, M) = \ceil{\frac{\abs{T}}{n}} + \ceil{\frac{\abs{M}}{n}} + 1\).
We then define our hash function \(H_h(T, M)\) as evaluation
of the polynomial \(H(T, M)\) at \(h\) for key \(h \in \bin^n\).

\subsection{XCTR mode}

HCTR depends for its proof of security
on an unusual mode of stream encryption.
\cite{hctr,hctr2} note the differences between this mode and CTR mode,
but use the same name to refer to it; for the avoidance of ambiguity
we name this mode \emph{XCTR mode}, and define:
\begin{displaymath}
    \XCTR_K(S) = E_K(S \xor \fromint(1)) \Concat E_K(S \xor \fromint(2)) \Concat E_K(S \xor \fromint(3)) \Concat \cdots
\end{displaymath}
thus generating the first \(m\) bits \(\XCTR_K(S)[0; m]\) takes \(\ceil{\frac{m}{n}}\) block cipher calls.

\subsection{HCTR2 encryption}

From these definitions, HCTR2 is as defined in \autoref{pseudocode}.
Note that what is referred to in \cite{hctr,hctr2} as \(C, \mathit{CC}, D\)
we refer to as \(Y, YY, Z\)
so that we can use \(P, C\) to refer to plaintext and ciphertext.
Tweaks may be any length from 0 to \(2^{n/2}-1\) bits, while
messages may be any length from \(n\) to \(n + 2^{n/2}-1\) bits.

\section{Implementation}


\section{Security of HCTR2}

\subsection{Hash function}
\begin{description}
    \item[Property 1]
    For any \(T, M\) and any \(g \in \bin^n\)
    there are at most \(d(T, M)\)
    values of \(h\) such that \(H_h(T, M) = g\).
    Proof: since the \(x\) term of \(H(T, M)\) is nonzero
    the polynomial \(H(T, M) \xor g\) is nonzero.
    Since the degree is at most \(d(T, M)\), it has
    at most that many zeroes.
    \item[Property 2] 
    \(\epsilon\)-almost-XOR-universality: 
    For any \((T_1, M_1) \neq (T_2, M_2)\) and any \(g \in \bin^n\)
    there are at most \(\max(d(T_1, M_1), d(T_2, M_2))\)
    values of \(h\) such that \(H_h(T_1, M_1) \xor H_h(T_2, M_2) = g\).
    Proof: \(H\) is injective, therefore
    \(H(T_1, M_1) \neq H(T_2, M_2)\)
    and \(H(T_1, M_1) \xor H(T_2, M_2) \neq 0\).
    Because the constant term of \(H\) is zero, 
    \(H(T_1, M_1) \xor H(T_2, M_2) \xor g \neq 0\).
    The degree is at most \(\max(d(T_1, M_1), d(T_2, M_2))\)
    and this limits the number of solutions.
    \item[Property 3]
    For any \((T_1, M_1), (T_2, M_2), (T_3, M_3)\) and any \(g \in \bin^n\)
    such that \(\abs{T_1} = \abs{T_2}\) and \(\abs{M_1} = \abs{M_2}\)
    there are at most \(\max(d(T_1, M_1), d(T_3, M_3))\)
    values of \(h\) such that
    \(H_h(T_1, M_1) \xor H_h(T_2, M_2) \xor H_h(T_3, M_3) = g\).
    Proof: the \(x\) term of \(H\) depends only on
    the lengths of the inputs; this term is therefore the same for
    \(H(T_1, M_1)\) and \(H(T_2, M_2)\) and so zero for 
    \(H(T_1, M_1) \xor H(T_2, M_2)\). Since this term
    is nonzero for \(H(T_3, M_3)\) it is therefore
    nonzero in
    \(H(T_1, M_1) \xor H(T_2, M_2) \xor H(T_3, M_3) \xor g\).
    This can therefore have no more solutions than
    its maximum degree,
    \(\max(d(T_1, M_1), d(T_3, M_3))\).
    \item[Property 4]
    For any \(T, M\) and any \(g \in \bin^n\)
    there are at most \(d(T, M)\)
    values of \(h\) such that \(H_h(T, M) \xor g = h\).
    Proof: the \(x\) coefficient of \(H\) cannot be identity,
    so \(H_h(T, M) \xor g \xor h\) cannot be zero, and
    therefore can have at most \(d(T, M)\) zeroes.
\end{description}

\subsection{Definitions}
\subsection{H-coefficient technique}

We prove the security of HCTR2 using Patarin's H-coefficient technique. 

\subsection{Main lemma} 
Let world X (the ``real world'') be \(\HCTR[\Perm(n)]\),
which is HCTR with all calls to the block cipher
replaced with calls to a random permutation.
Let world Y (the ``ideal world'') be \(\pm\rnd\),
in which all queries are answered randomly.
We forbid ``pointless queries'':
encryption queries \(P, T\)
which are identical to previous encryption queries
or for which the value \(P\) was returned from a prior
decryption  query \(C, T\), or
decryption queries \(C, T\)
which are identical to previous decryption queries
or for which the value \(C\) was returned from a prior
encryption  query \(P, T\).

After all queries are complete, we give the attacker
extra information
which is included in the transcript;
this cannot make
their performance worse. In the ``real world'', 
this information is:
\begin{itemize}
    \item the hash key \(h\)
    \item the ``leftover block'' for each query:
    where a query has plaintext/ciphertext
    that is not a multiple of the block size,
    this is the extra output from the last
    blockcipher call that is not used.
    For query \(i\) this is 
    \[\XCTR(S^i)[\abs{P}; n\ceil{\frac{\abs{P}}{n}}-\abs{P}]\]
\end{itemize}
In the ``ideal world'', random output of the expected
length is substituted.

\subsection{Security bound}

\printbibliography[heading=bibintoc]

\end{document}
