% Copyright 2021 Google LLC
%
% Use of this source code is governed by an MIT-style
% license that can be found in the LICENSE file or at
% https://opensource.org/licenses/MIT.

%!TeX spellcheck = en-US

\documentclass[letterpaper,11pt]{article}

\usepackage{floatrow}
\usepackage{algpseudocode}
\usepackage{amsmath}
\usepackage[style=alphabetic,backend=biber,alldates=ymd]{biblatex}
\usepackage{bm}
\usepackage[logic,probability,advantage,adversary,landau,sets,operators]{cryptocode}
\usepackage{hyperref}
\usepackage{tikz}

\usetikzlibrary{groupops}

\addbibresource{bib.bib}

\newcommand*{\Concat}{\Vert}
\newcommand*{\defeq}{\stackrel{\text{def}}{=}}
\newcommand*{\MM}{\mathit{MM}}
\newcommand*{\qeq}{\stackrel{\text{?}}{=}}
\newcommand*{\Tb}{\mathcal{T}_\mathrm{bad}}
\newcommand*{\Tc}{\mathcal{T}_\mathrm{c}}
\newcommand*{\Tg}{\mathcal{T}_\mathrm{good}}
\newcommand*{\UU}{\mathit{UU}}

\DeclareMathOperator{\fromint}{bin}
\DeclareMathOperator{\GF}{GF}
\DeclareMathOperator{\HCTR}{HCTR2}
\DeclareMathOperator{\pad}{pad}
\DeclareMathOperator{\Perm}{Perm}
\DeclareMathOperator{\poly}{poly}
\DeclareMathOperator{\XCTR}{XCTR}

\title{HCTR2}

\begin{document}
\maketitle

\begin{abstract}
\end{abstract}

\section{Introduction}
The construction HCTR\cite{hctr} is among the most efficient for 
tweakable length-preserving encryption from a block cipher, using
a single block cipher invocation and two \(GF(2^n)\) multiplies
per block. Unfortunately, as presented it has two serious flaws.
The first, observed in \cite{kumarhctr}, is that the hash function
is not \(\epsilon\)-almost-XOR-universal\cite{eadu} as claimed.
The second is that an error in the proof presented in \cite{hctrquad}
invalidates the claimed quadratic security bound, leaving
only an unsatisfactory cubic bound. 

This paper proposes a new revision, HCTR2, fixing these issues.
We know of no patents affecting use of HCTR2.
\cite{adiantum} includes a detailed history of length-preserving encryption.
We begin with the specification and proof for HCTR2, laying
the groundwork for describing the flaws with HCTR (\autoref{hctrflaws}),
after which we discuss HCTR2 design decisions
and report on its implementation on x86-64 and ARM64.

\section{Specification}
\begin{figure}
    \input{hctr2fig.tex}
    \caption{HCTR2}\label{hctr2fig}
\end{figure}
\begin{figure}
    \begin{floatrow}
        \ffigbox{
            \begin{algorithmic}[0]
                \Procedure{\(HCTR2_{k, T}\)}{$P$}
                \State $h \gets E_k(\fromint(0))$
                \State $L \gets E_k(\fromint(1))$
                \State $M \Concat N \gets P$, $|M| = n$
                \State $\MM \gets M \xor H_h(T, N)$
                \State $\UU \gets E_k(\MM)$
                \State $S \gets \MM \xor \UU \xor L$
                \State $V \gets N \xor \XCTR_k(S)[0;\abs{N}]$
                \State $U \gets \UU \xor H_h(T, V)$
                \State $C \gets U \Concat V$
                \State \textbf{return} $C$
                \EndProcedure
            \end{algorithmic}
        }{
            \caption{HCTR2 encryption}\label{pseudocode}
        }
        \ffigbox{
            \begin{algorithmic}[0]
                \Procedure{\(HCTR2_{k, T}^{-1}\)}{$C$}
                \State $h \gets E_k(\fromint(0))$
                \State $L \gets E_k(\fromint(1))$
                \State $U \Concat V \gets C$, $|U| = n$
                \State $\UU \gets U \xor H_h(T, V)$
                \State $\MM \gets E_k^{-1}(\UU)$
                \State $S \gets \MM \xor \UU \xor L$
                \State $N \gets V \xor \XCTR_k(S)[0;\abs{V}]$
                \State $M \gets \MM \xor H_h(T, N)$
                \State $P \gets M \Concat N$
                \State \textbf{return} $P$
                \EndProcedure
            \end{algorithmic}
        }{
            \caption{HCTR2 decryption}
        }
    \end{floatrow}
\end{figure}
\subsection{Notation}
Subscripts may denote partial application; if we define $f: A \times B \rightarrow C$ and
$a \in A$ then $f_a: B \rightarrow C$, and if $f_a^{-1}$ exists then $f_a^{-1}(f_a(b)) = b$.
\begin{itemize}
    \item $\abs{X}$: length of $X \in \bin^{*}$ in bits
    \item $\lambda$: the empty string $\abs{\lambda} = 0$
    \item $\Concat$: bitstring concatenation
    \item \(\xor\): bitwise XOR
    \item $Y[a;l]$: the substring of $Y$ of length $l$ starting at the 0-based index $a$
    \item \(n\): block size in bits; we assume \(n\) is even
    \item $\fromint_l: \{0 \ldots 2^l-1\} \rightarrow \bin^l$:
    little-endian conversion of integers to binary; 
    \(\fromint(X)\) means \(\fromint_n(X)\)
    \item $\pad(X) = X \Concat 0^v$
    where $v$ is the least integer $\geq 0$ such that $n$ divides $\abs{X} + v$
    \item \(E: \mathcal{K} \times \bin^n \rightarrow \bin^n\): 
    \(n\)-bit block cipher with keyspace \(\mathcal{K}\);
    our concrete proposal uses AES, so \(n=128\) and \(\mathcal{K}\) is
    \(\bin^{128}\), \(\bin^{192}\), or \(\bin^{256}\)
    \item \(\mathcal{T}\): the set of permissible tweaks
    \(\mathcal{T} = \bigcup_{i \in \{0\ldots2^{n-1}-2\}}\bin^i\)
    \item \(\mathcal{M}\): the set of permissible messages
    \(\mathcal{M} = \bigcup_{i \in \{n\ldots2^{n-1}-2\}}\bin^i\)
\end{itemize}
We map bytes to bitstrings with \(\fromint_8\).

\subsection{Polynomial hash function}
We interpret \(n\)-bit blocks as little-endian field elements of \(\GF(2^n)\),
so \(001 \Concat 0^{n-3}\) is interpreted as the element \(x^2\).
Where \(n=128\) we reduce by
\(1 + x + x^2 + x^7 + x^{128}\). Then let
\begin{displaymath}
    \poly(M_0 \Concat M_1 \Concat \cdots \Concat M_{l-2} \Concat M_{l-1})
\end{displaymath}
refer to the polynomial
\begin{displaymath}
    p(h) = M_0h^{l-1} \xor M_1h^{l-2} \xor \cdots \xor M_{l-2}h \xor M_{l-1}
\end{displaymath}

We define a polynomial for tweak \(T\) and message \(M\). Where \(n\) divides
\(\abs{M}\) this is
\begin{displaymath}
    H(T, M) = \poly(\fromint(2\abs{T} + 2) \Concat \pad(T) \Concat M \Concat 0^n)
\end{displaymath}
otherwise this is
\begin{displaymath}
    H(T, M) = \poly(\fromint(2\abs{T} + 3) \Concat \pad(T) \Concat \pad(M \Concat 1) \Concat 0^n)
\end{displaymath}

We then define our hash function \(H_h(T, M)\) as evaluation
of the polynomial \(H(T, M)\) at \(h\) for key \(h \in \bin^n\).

\subsection{XCTR mode}

HCTR and HCTR2 use an unusual mode of stream encryption.
\cite{hctr,hctrquad} note the differences between this mode and CTR mode,
but use the same name to refer to it; for the avoidance of ambiguity
we name this mode \emph{XCTR mode}, and define:
\begin{displaymath}
    \XCTR_k(S) = E_k(S \xor \fromint(1)) \Concat E_k(S \xor \fromint(2)) \Concat E_k(S \xor \fromint(3)) \Concat \cdots
\end{displaymath}
thus generating the first \(m\) bits \(\XCTR_k(S)[0; m]\) takes \(\ceil{m/n}\) block cipher calls.

\subsection{HCTR2 encryption}

From these definitions, HCTR2 is as defined in \autoref{pseudocode}.
Note that what is referred to in \cite{hctr,hctrquad} as \(C, \mathit{CC}, D\)
we refer to as \(U, \UU, V\)
so that we can use \(P, C\) to refer to plaintext and ciphertext.

\section{Security of HCTR2}
\subsection{Definitions}

The block cipher
$E$
must be a super-pseudorandom permutation~\cite{concrete}:
%
\begin{align*}
    \advantage{\pm \mathrm{prp}}{E}[(A)] \defeq
    {}&\left\lvert\probsub{k \sample \mathcal{K}}{A^{E_k,E_k^{-1}}\Rightarrow 1}\right.
    \\
    {}&\left. - \probsub{\pi \sample \Perm(n)}{A^{\pi,\pi^{-1}}\Rightarrow 1}\right\rvert
    \\
    \advantage{\pm \mathrm{prp}}{E}[(q, t)] \defeq
    {}&\max_{A \in \mathcal{A}(q, t)} \advantage{\pm \mathrm{prp}}{E}[(A)]
\end{align*}
%
where $A$ is an adversary,
$\Perm(S)$ denotes the set of all permutations on a set $S$,
$\Perm(n)$ is short for $\Perm(\bin^n)$
and
$\mathcal{A}(q, t)$
is the set of all adversaries that make at most $q$ queries and take at most $t$ time.

Let $\Perm^\mathcal{T}(\mathcal{M})$
denote the set of all
tweakable length-preserving permutations
$\bm{\pi} : \mathcal{T} \times \mathcal{M} \rightarrow \mathcal{M}$
such that for all $T, M \in \mathcal{T} \times \mathcal{M}$,
$\abs{\bm{\pi}(T, M)} = \abs{M}$, and
for all $T \in \mathcal{T}$, $\bm{\pi}_{T}$ is a bijection on \(\mathcal{M}\).
In an abuse of notation
we use $\bm{\pi}^{-1}$ to refer to the function
such that $\bm{\pi}^{-1}(T, \bm{\pi}(T, M)) = M$ ie $(\bm{\pi}^{-1})_T = (\bm{\pi}_T)^{-1}$.

Per~\cite{cmc}, for a tweakable super-pseudorandom permutation
$\bm{E} : \mathcal{K} \times \mathcal{T} \times \mathcal{M} \rightarrow \mathcal{M}$
the distinguishing advantage of an adversary $A$ is:
%
\begin{align*}
    \advantage{\pm \widetilde{\mathrm{prp}}}{\bm{E}}[(A)] \defeq
    {}&\left\lvert\probsub{K \sample \mathcal{K}}{A^{\bm{E}_k,\bm{E}_k^{-1}}\Rightarrow 1}\right.
    \\
    {}&\left. - \probsub{\bm{\pi} \sample \Perm^\mathcal{T}(\mathcal{M})}
        {A^{\bm{\pi},\bm{\pi}^{-1}}\Rightarrow 1}\right\rvert
    \\
    \intertext{We then define}
    \advantage{\pm \widetilde{\mathrm{prp}}}{\bm{E}}[(q, \sigma, t)]
    \defeq {}&
    \max_{A \in \mathcal{A}(q, \sigma, t)} \advantage{\pm \widetilde{\mathrm{prp}}}{\bm{E}}[(A)]
\end{align*}
where \(\mathcal{A}(q, \sigma, t)\)
is the set of all adversaries 
making at most \(q\) queries
and taking at most \(t\) time,
such that the total of all blocks sent in queries is
at most \(\sigma\) ie
\begin{displaymath}
    \sum_s \ceil{|T^s|/n} + \ceil{|M^s|/n} \leq \sigma
\end{displaymath}
and \(T^s, M^s\) are the tweak and message
(plaintext or ciphertext)
presented in query \(s\).

We use \(\HCTR[\pi]\) to refer to HCTR2 in which invocation
of the block cipher is replaced with invocation of the
permutation \(\pi \in \Perm(n)\); thus for key
\(k \in \mathcal{K}\) regular HCTR2 is \(\HCTR[E_k]\).
\(\XCTR_\pi\) refers to a similar substitution.
\(\HCTR[E]\) refers to regular HCTR2,
ie \(\HCTR[E_k]\) for \(k \sample \mathcal{K}\), while
\(\HCTR[\Perm(n)]\) refers to \(\HCTR[\pi]\)
for \(\pi \sample \Perm(n)\).

\subsection{Hash function}\label{hproperties}
For any nonzero polynomial \(p(h)\)
in \(GF(2^n)\) 
of degree \(d\), there are at most \(d\) values \(h\)
such that \(p(h) = 0\), and therefore
\(\probsub{h\sample{\bin^n}}{p(h) = 0} \leq d/2^n\).
We depend on the following properties of the map from 
\(H(T, M)\) to polynomials:
\begin{itemize}
    \item The map is injective
    \item The constant term is always zero
    \item The polynomial is never \(p(h) = 0\) or \(p(h) = h\).
    \item The polynomial is of degree at most
    \begin{displaymath}
        d(T, M) = 1 + \ceil{\abs{T}/n} + \ceil{\abs{M}/n}
    \end{displaymath}
\end{itemize}
Note that these are all considerations about the polynomial,
not about the value \(H_h(T, M)\);
for example we may have \(H_h(T, M) = h\) for some values of \(h\).

From this we infer three properties of \(H_h(T, M)\):
\begin{description}
    \item[Property 1]
    For any \(T, M\) and any \(g \in \bin^n\),
    \begin{displaymath}
        \probsub{h\sample{\bin^n}}{H_h(T, M) = g} \leq d(T, M)/2^n
    \end{displaymath}
    Proof: since \(H(T, M)\) is nonzero and has
    a zero constant term,
    the polynomial \(H(T, M) \xor g\) 
    is nonzero,
    has the same degree,
    and therefore has at most \(d(T, M)\) zeroes.
    \item[Property 2] 
    For any \((T_1, M_1) \neq (T_2, M_2)\) and any \(g \in \bin^n\)
    \begin{align*}
        & \probsub{h\sample{\bin^n}}{H_h(T_1, M_1) \xor H_h(T_2, M_2) = g} \\
        \leq  & \max(d(T_1, M_1), d(T_2, M_2))/2^n
    \end{align*}
    Proof: \(H\) is injective onto polynomials
    and the constant term is zero, therefore
    \(H(T_1, M_1) \xor H(T_2, M_2) \xor g\)
    is not the zero polynomial.
    The degree is at most \(\max(d(T_1, M_1), d(T_2, M_2))\)
    and this limits the number of solutions.
    This shows that the hash function is
    \(\epsilon\)-almost-XOR-universal.
    \item[Property 3]
    For any \(T, M\) and any \(g \in \bin^n\)
    \begin{displaymath}
        \probsub{h\sample{\bin^n}}{H_h(T, M) \xor h = g} \leq d(T, M)/2^n
    \end{displaymath}
    Proof: \(H(T, M)\) has a zero constant term and
    cannot be equal to the polynomial \(p(h) = h\),
    so \(H(T, M) \xor g \xor h\) cannot be the zero polynomial, and
    therefore can have at most \(d(T, M)\) zeroes.
\end{description}

\subsection{H-coefficient technique}
The H-coefficient technique was introduced by Patarin in 1991~\cite{ppdes,hco}.
We highly recommend the exposition
of~\cite{hco2} Section 3,
``The H-coefficient Technique in a Nutshell'';
we here present a simpler exposition that
does not cover the technique in its full
generality but only our use of it.
Our use of the symbol \(\mathcal{T}\) and the term
``compatible'' differs slightly from~\cite{hco2}.

We wish to bound the adversary's ability to distinguish between
two ``worlds'', world X (the ``real world'') and world Y (the ``ideal world'').
Each world is a probability distribution over oracles the adversary
interacts with.

We consider only deterministic adversaries.
A randomized adversary can be considered as a random draw
from a population of deterministic adversaries, so
a bound on the advantage achievable by a deterministic
adversary bounds the whole pool and therefore
the advantage of the randomized adversary. In what follows
we consider the adversary fixed; only the world, and the
particular oracles drawn from that world, vary.

When the adversary interacts with the oracle,
a transcript \(\tau\) of queries and responses is created.
\(\Tc\) is the set of ``compatible transcripts'':
if \(\tau \in \Tc\) then for the fixed adversary,
there is some oracle
that results in its creation. For example,
since the adversary is deterministic, the first query
will always be the same; a transcript that
does not start with this query is not a compatible transcript.
Let random variables \(X\) and \(Y\)
represent the distribution of transcripts
in world X and world Y respectively, so that
each transcript \(\tau\) has a probability \(\prob{X = \tau}\)
of arising in world X, and similarly \(\prob{Y = \tau}\) in world Y.
For a given \(\tau \in \Tc\),
a deterministic adversary must always
return the same response; call this response \(A(\tau)\).
WLOG we assume that \(\prob{A(Y) = 1} \geq \prob{A(X) = 1}\).
We further assume that \(A\) is optimal:
\(A(\tau) = 1\)
when \(\prob{Y = \tau} > \prob{X = \tau}\) and 0 otherwise.

In \autoref{mainlemma}, we partition \(\Tc\) into \(\Tg\) and \(\Tb\). 
We prove that for all \(\tau \in \Tg\)
\(\prob{Y = \tau} \leq \prob{X = \tau}\),
and that \(\prob{Y \in \Tb} \leq \epsilon\).
It follows that \(A(\tau) = 0\) for all \(\tau \in \Tg\),
and therefore that \(\prob{A(Y) = 1} \leq \epsilon\),
from which we bound the distinguishing advantage:
\(\prob{A(Y) = 1} - \prob{A(X) = 1} \leq \epsilon\).

\subsection{Main lemma}\label{mainlemma}
In what follows, we take world X (the ``real world'') 
to be \(\HCTR[\Perm(n)]\),
ie HCTR with all calls to the block cipher
replaced with calls to a random permutation,
and world Y (the ``ideal world'') to be \(\pm\widetilde{\mathrm{rnd}}\),
which maps every query to a random response such that
all responses of the appropriate length are equally likely;
we then use the H-coefficient technique to bound
the distinguishing advantage between them.

We use superscripts to distinguish between queries;
where we refer to \(s\), \(s'\), we assume that \(s < s'\).
An encryption query \((T^s, P^s)\) yields ciphertext \(C^s\)
while a decryption query \((T^s, C^s)\)
yields plaintext \(P^s\).
We forbid ``pointless queries'':
encryption queries \((T^{s'}, P^{s'})\)
such that \((T^s, P^s) = (T^{s'}, P^{s'})\) for some \(s < s'\), 
or decryption queries \((T^{s'}, C^{s'})\)
such that \((T^s, C^s) = (T^{s'}, C^{s'})\) for some \(s < s'\),
whether query \(s\) was an encryption or decryption query.

For each query \(s\), 
let \(m^s = \ceil{\abs{P^s}/n} = \ceil{\abs{C^s}/n}\)
be the number of blocks in the response,
and let \(d^s = m^s + \ceil{\abs{T^s}/n}\)
be the number of blocks in the query.
Note that \(d^s\) is the degree of the hash
function polynomial used in query \(s\),
and that \(\sigma = \sum_s d^s\).
We give the adversary some extra information
which is included in the transcript.
In world X, this information is:
\begin{itemize}
    \item the ``leftover block'' for each query:
    where a query has plaintext/ciphertext
    that is not a multiple of the block size,
    this is the extra output from the last
    blockcipher call that is not used.
    For query \(s\), this is 
    \begin{displaymath}
        D^s = \XCTR_\pi(S^s)[\abs{P^s} - n; nm^s-\abs{P^s}]
    \end{displaymath}
    \item the hash key \(h\), given after all queries are complete
    \item the mask \(L\), given after all queries are complete
\end{itemize}
In the ``ideal world'', random output of the expected
length is substituted. Since the adversary can always ignore
this information, giving it to them cannot make their performance worse.

For \(j \in \{1 \ldots m^s-1\}\) we define \(S_j^s = S^s \xor \fromint(j)\),
the block cipher inputs used in \(\XCTR\), and \(Y_j^s\) the corresponding
outputs, so that \(Y_j^s = \pi(S_j^s)\) and 
\(Y_1^s \Concat \cdots \Concat Y_{m^s-1}^s = \XCTR_\pi(S^s)[0;n(m^s -1)] 
= (N^s \xor V^s) \Concat D^s\).

Given the full transcript, including \(h\) and \(L\),
we can infer all pairs of block cipher plaintexts and ciphertexts.
First we infer that \(h = \pi(\fromint(0))\) and \(L = \pi(\fromint(1))\).
Then for each query, we know \(T\), \(P\), \(C\) and \(D\)
and so can infer
(omitting the query superscript \(i\) for readability):
\begin{align*}
    M \Concat N &= P \\
    U \Concat V &= C \\
    \MM &= M \xor H_h(T, N)\\
    \UU &= U \xor H_h(T, V)\\
    \UU &= \pi(\MM)\\
    S &= \MM \xor \UU \xor L\\ 
    S_i &= S \xor \fromint(i)\\
    Y_1 \Concat \cdots \Concat Y_{m-1} &= (N \xor V) \Concat D \\
    Y_j &= \pi(S_j) \\
\end{align*}
We therefore infer \(\sigma_m = 2 + \sum_s m^s \) block cipher
plaintext/ciphertext pairs from \(\sigma_m n\) bits of query response.

A transcript is ``bad'' (\(\tau \in \Tb\)) iff any pair of 
inferred block cipher plaintexts are the same
(\(\MM^s\), \(S_j^s\), \(\fromint(0)\), \(\fromint(1)\))
or any pair of inferred block cipher ciphertexts are the same
(\(\UU^s\), \(Y_j^s\), \(h\), \(L\)).

Since responses in world Y are coin flips,
the probability of a 
particular \(\tau \in \Tc\), good or bad,
in world Y is always simply \(2^{-\sigma_m n}\).
For a transcript \(\tau \in \Tg\),
the probability in world X
is the probability of all of those plaintext/ciphertext
pairs being part of a given random permutation.
This is 
\(\prod_{i=0}^{\sigma_m -1}(1/(2^n - i))\).
Thus for all \(\tau \in \Tg\)
\(\prob{Y = \tau} \leq \prob{X = \tau}\). 

Next we bound \(\prob{Y \in \Tb}\).
We consider a case by case analysis of
each of the kinds of collisions that are
possible, and bound the probability in each case.

In the ideal world responses to queries are random,
but some caution is required.
If we know the adversary's query \(s'\), then conditioning on that,
we cannot treat the response to query \(s\) as uniformly random;
if the choice of later query depends on the earlier response,
knowing the later query is information about the earlier response.
However, conditioning on a query and all prior queries and responses,
in world Y we still have that \(h\), \(L\), and the
query response are uniformly random and independent,
and so we can consider them in any order.

In most cases, the probability of a collision
between two specific blocks is bounded by \(1/2^n\).

\begin{itemize}
    \item \(h \qeq L\): trivially has probability \(1/2^n\).
    \item
    \(h \qeq Y_j^{s'}\),
    \(L \qeq Y_j^{s'}\),
    \(\UU^s \qeq Y_j^{s'}\),
    \(Y_i^s \qeq Y_j^{s'}\):
    in each case, given \(h\), \(L\), query \(s'\), 
    and all prior queries and responses, 
    \(1/2^n\) possible responses to query \(s'\)
    result in the desired equation holding.
    \item
    \(\UU^{s'} \qeq Y_j^{s'}\), 
    \(Y_i{s'} \qeq Y_j^{s'}\): 
    if \(s'\) is an encryption query
    then given \(h\), \(L\), query \(s'\), and 
    \(C^{s'}[0;jn]\), there is exactly one value of
    \(C^{s'}[jn;n]\) that results in the equation holding.
    If \(s'\) is a decryption query, the same reasoning holds
    with \(P^{s'}\), \(C^{s'}\) swapped.
    \item 
    \(\fromint(0) \qeq S_j^{s'}\),
    \(\fromint(1) \qeq S_j^{s'}\),
    \(\MM^s \qeq S_j^{s'}\),
    \(S_i^s \qeq S_j^{s'}\):
    if query \(s'\) is an encryption query,
    then given \(h\), \(L\), query \(s'\), 
    and all prior queries and responses,
    there is exactly one response value \(U^{s'}\)
    that results in the equation holding.
    For a decryption query, 
    there is exactly one response value \(M^{s'}\)
    that results in the equation holding.
    \item
    \(\MM^{s'} \qeq S_j^{s'}\):
    given \(h\), \(T^{s'}\), \(P^{s'}\), \(C^{s'}\),
    there is exactly one value of \(L\)
    which causes this equation to hold.
    \item 
    \(S_i^s \qeq \MM^{s'}\):
    given \(h\) and all queries and responses,
    there is exactly one value of \(L\)
    which causes the equation to hold.
    \item \(L \qeq \UU^{s'}\):
    given \(h\) and all queries and responses,
    there is exactly one value of \(L\)
    which causes the equation to hold.
\end{itemize}

In two cases, a collision is impossible.

\begin{itemize}
    \item \(\fromint(0) \qeq \fromint(1)\): trivially impossible.
    \item 
    \(S_i^{s'} \qeq S_j^{s'}\):
    this is impossible, 
    \(S_i^{s'} \xor S_j^{s'} = \fromint(i) \xor \fromint(j)\).
\end{itemize}

There are a handful of cases where the probability may
be greater than \(1/2^n\).

Considering first collisions with \(\MM^{s'}\) where
query \(s'\) is an encryption query:

\begin{itemize}
    \item \(\MM^s \qeq \MM^{s'}\):
    this holds if \(M^s \xor H_h(T^s, N^s) = M^{s'} \xor H_h(T^{s'}, N^{s'})\);
    by hash function property 2, this holds with probability at most
    \(\max(d^s, d^{s'})/2^n\).
    \item \(\fromint(0) \qeq \MM^{s'}\):
    this holds if \(\fromint(0) = M^{s'} \xor H_h(T^{s'}, N^{s'})\);
    by hash function property 1, this holds with probability at most
    \(d^{s'}/2^n\).
    \item \(\fromint(1) \qeq \MM^{s'}\): as above.
\end{itemize}

In each case, if query \(s'\) is a decryption query,
then given \(h\), query \(s'\), and all prior
queries and responses, all values of \(M^{s'}\)
are equally likely and a single value causes
the equation to hold, for a probability of
\(1/2^n\).

Similarly, considering collisions with \(\UU^{s'}\) where
query \(s'\) is a decryption query:

\begin{itemize}
    \item \(\UU^s \qeq \UU^{s'}\): 
    this holds if \(U^s \xor H_h(T^s, V^s) = U^{s'} \xor H_h(T^{s'}, V^{s'})\);
    by hash function property 2, this holds with probability at most
    \(\max(d^s, d^{s'})/2^n\).
    \item \(Y_j^s \qeq \UU^{s'}\):
    this holds if \(Y_j^s = U^{s'} \xor H_h(T^{s'}, C^{s'})\);
    by hash function property 1, this holds with probability at most
    \(d^{s'}/2^n\).
    \item \(h \qeq \UU^{s'}\):
    this holds if \(h = U^{s'} \xor H_h(T^{s'}, C^{s'})\);
    by hash function property 3, this holds with probability at most
    \(d^{s'}/2^n\).
\end{itemize}

As above, if query \(s'\) is an encryption query,
then given \(h\), query \(s'\), and all prior
queries and responses, all values of \(U^{s'}\)
are equally likely and a single value causes
the equation to hold, for a probability of
\(1/2^n\).

Given that most pairs have a probability of
colliding of \(1/2^n\), we apply a strategy
of starting from the assumption that all such
pairs have this probability bound, and then
applying a correction for the ones that don't,
as we illustrate below.

To bound the probability an encryption query \(s'\)
has some collision with the fixed values
\(h = \pi(\fromint(0))\) and \(L = \pi(\fromint(1))\)
we observe first that
there are two blocks in the fixed values
and \(m^{s'}\) in query \(s'\), so there are
\(2m^{s'}\) pairs of blocks across the two,
and \(4m^{s'}\) opportunities for a collision, 
considering both plaintext and ciphertext.
If all pairs had collision probability \(1/2^n\),
then the overall collision probability bound
would be \(4m^{s'}/2^n\). However, there are
two exceptions: the pairs
\(\fromint(0) \qeq \MM^{s'}\) and
\(\fromint(1) \qeq \MM^{s'}\). In each of these
cases the probability bound is not \(1/2^n\) but
\(d^{s'}/2^n\), We therefore apply a correction
of \(2(d^{s'} - 1)\) to get a final probability bound of
\begin{displaymath}
    \frac{4m^{s'} + 2(d^{s'} - 1)}{2^n}
\end{displaymath}

Similarly, the correction for a decryption query is
\(d^{s'} - 1\) and therefore  the probability 
is bounded above by
\begin{displaymath}
    \frac{4m^{s'} + d^{s'} -1}{2^n}
\end{displaymath}
The largest of the two correction formulas is
the first one, so we use that for our overall bound.
Across all queries, the total
correction will be
\begin{align*}
    &\sum_{s'} 2(d^{s'} - 1) \\
    = & 2(\sigma - q)
\end{align*}

For a collision of two blocks within query \(s'\)
the correction formula is negative:
\(S_i^{s'} \qeq S_j^{s'}\) is an impossible collision, 
so we subtract the number of such blocks:
\(-\binom{m^{s'} -1}{2}\). However we have no good way
to impose a useful lower bound on the negative sum
\(\sum_{s'}-\binom{m^{s'} -1}{2}\) so we use the
trivial lower bound of 0.

Where an encryption query \(s'\)
may collide with query \(s\), the correction factor is 
\(\max(d^s, d^{s'}) -1\), whereas for a decryption query
it is \(\max(d^s, d^{s'}) -1 + (m^s -1 )(d^{s'} -1)\).
Taking the max of these formulas and summing across
all queries gives us a total correction of
\begin{align*}
    &\sum_{s < s'} \max(d^s, d^{s'}) -1 + (m^s -1 )(d^{s'} -1)\\
    \leq & \sum_{s < s'} d^s + d^{s'} -1 + (m^s -1 )(d^{s'} -1)\\
    = & (q-1)\sigma - \binom{q}{2} + \sum_{s < s'} (m^s -1 )(d^{s'} -1) \\
    \leq & (q-1)\sigma - \binom{q}{2} + \sum_{s < s'} d^sd^{s'} \\
    % fixme last step seems a bit loose
    \leq & (q-1)\sigma - \binom{q}{2} + \binom{\sigma}{2} \\
   \leq & (q-1)\sigma + \binom{\sigma}{2} \\
\end{align*}

The correction factor for collision between fixed values
is -1, reflecting the impossibility of the collision
\(\fromint(0) \qeq \fromint(1)\).

Thus our total correction factor is

\begin{align*}
    & 2(\sigma - q) + (q-1)\sigma + \binom{\sigma}{2} -1 \\
    = & \sigma - 2q + q\sigma +  \frac{\sigma^2 - \sigma}{2} \\
    \leq & \frac{1}{2}\sigma(\sigma + 2q + 1) \\
\end{align*}

Applying the H-coefficient technique, we therefore conclude that
\begin{align*}
    & \advantage{\pm\widetilde{\mathrm{rnd}}}{\HCTR[\Perm(n)]}[(q, \sigma, t)] \\
    \leq & \prob{Y \in \Tb} \\
    \leq & \sigma(\sigma + 2q + 1)/2^{n+ 1}
\end{align*}

\subsection{Security bound}
By a standard substitution argument~\cite{cbcsec,concrete} we have that
\begin{displaymath}
    \advantage{\HCTR[\Perm(n)]}{\HCTR[E]}[(q, \sigma, t)]
    \leq \advantage{\pm \mathrm{prp}}{E}[(\sigma + 2, t + \sigma t')]
\end{displaymath}
where \(t'\) is a small constant
representing the per-block cost of simulating HCTR2, and
\(\sigma + 2\) bounds the number of block cipher calls made by the simulator.
Since \(q \leq \sigma\), Halevi and Rogaway's PRP-RND lemma
(\cite{cmc}, Appendix C, Lemma 6) tells us that
\begin{displaymath}
    \advantage{\pm \widetilde{\mathrm{prp}}}{\pm\widetilde{\mathrm{rnd}}}[(q, \sigma, t)] 
    \leq \left.\binom{q}{2}\middle/2^n\right.
    \leq q^2/2^{n+1}
\end{displaymath}
Putting these together with our main lemma, we have that
\begin{displaymath}
    \advantage{\pm \widetilde{\mathrm{prp}}}{\HCTR[E]}[(\sigma, t)] \leq \advantage{\pm \mathrm{prp}}{E}[(\sigma, t + \sigma t')]
    + \sigma(\sigma + q + 1)/2^n
\end{displaymath}

\section{HCTR issues}\label{hctrflaws}
Two serious flaws in HCTR motivated the design of HCTR2.
\subsection{Hash function}
HCTR uses a hash function based on the polynomial
\begin{displaymath}
    H(X) = \poly(\pad(X) \Concat \fromint(X) \Concat 0^n)
\end{displaymath}
Because it assumes a fixed-length tweak it simply sets \(X = M \Concat T\).
However, HCTR requires that the resulting polynomial be nonzero
even when \(X = \lambda\), so as a special case they define
\(H(\lambda) = h\).

Unfortunately, as \cite{kumarhctr} observes this is no longer
an injective map from \(X\) - we also have \(H(0) = h\). This
straightforwardly leads to an attack in which two encryption queries
are presented, one of a block width, and the second extending
the first with a single zero (and assuming a zero length tweak).

\subsection{Security bound}
\cite{hctr} was initially presented with a security bound cubic
in the total size of all queries combined.  This is a little low
for comfort; if a 128-bit blockcipher is used, it suggests a
distinguisher can be effective given tens of terabytes of queries,
which can quickly be reached over a fast link. 
\cite{hctrquad} presents a much more satisfactory quadratic bound.
However, it appears the proof of that bound has a critical error.

While presented in a different way, this proof is very similar
to that of this paper: in the game RAND2, all queries get random
responses, the block cipher inputs are inferred, and a collision
in either the domain or range of the block cipher
sets the ``bad'' flag. Where that paper refers to 
\(C, \mathit{CC}, D\)
we refer to as \(U, \UU, V\). Where HCTR2 has
\(S = \MM \xor \UU \xor L\), HCTR simply has
\(S = \MM \xor \UU\). HCTR uses a fixed-length tweak
of length \(t\); for simplicity we assume \(t = 0\)
in what follows.

For equation 17, the paper observes that the collision
\(Y_i^s = \UU^{s'}\) occurs iff \(h\) is one of the zeroes
of the polynomial \(Y_i^s \xor U^{s'} \xor H(T^{s'}, V^{s'})\).
This polynomial has degree at most
\(m^{s'}\), and so can have
at most that many solutions. From this the paper infers
a quadratic bound on the probability of any such collision
given \(\sigma\) input blocks.

In equation 22, the paper considers collisions of the form 
\(S_i^s = \MM^{s'}\) and asserts that they are
quadratically bounded for the same reason. However this equation
is crucially different: unlike with \(Y_i^s\), the value we
infer for \(S_i^s\) depends on \(h\). The values of \(h\)
for which this collision occurs are
the zeroes of the polynomial
\begin{displaymath}
    M^s \xor H(T^s, N^s)
    \xor U^s \xor H(T^s, V^s) \xor \fromint(i) 
    \xor M^{s'} \xor H(T^{s'}, N^{s'})        
\end{displaymath}
This polynomial can have degree up to 
\(\max(m^s, m^{s'})\), and so the bound of
equation 17 does not apply.
Consider an adversary who
sends a single query with \(x+1\) blocks, followed by
\(x\) queries of one block. For each \(i \in \{1\ldots x\}\) and
for each \(s \in \{2 \ldots x + 1\}\), we have at best
\(\prob{S_i^s = \MM^{s'}} \leq (x + 1)/2^n\). Summing
all these bounds for each such pair, we find that
for queries with \(\sigma = 2x + 1\)
get a bound for the overall probability of such a collision of 
\((x^3 + x^2)/2^n\)---clearly a cubic, not quadratic bound.

\section{Design of HCTR2}
HCTR2 is intended as a successor to HCTR and retains several of the
crucial features that make it an attractive design:
\begin{itemize}
    \item An unbalanced Feistel-like network based on universal
    hashing, with a single block encryption on the narrow side.
    This gives us excellent performance and parallelizability,
    as well as very natural handling of messages that are not
    a multiple of the block size.
    \item Use of \(\MM \xor \UU\) in generating \(S\), which means
    that an adversary's control over \(S\) is very limited for both
    encryption and decryption queries; this is important in the
    proof of security.
    \item The CTR mode variant \(\XCTR\); while HCTR2 (unlike HCTR)
    does not require this mode for its security proofs, 
    we prefer not to change it unnecessarily, and this mode is
    attractive for performance reasons when using a full-block-sized
    nonce, since a full-block-sized counter need not be maintained
    if messages are always short.
\end{itemize}

In designing HCTR2 we made the following changes from HCTR and design decisions:

\begin{itemize}
    \item To achieve a quadratic security bound, we introduce the extra
    key-dependent constant \(L\),
    so that where HCTR has \(S = \MM \xor \UU\)
    we have \(S = \MM \xor \UU \xor L\).
    \item We allow a variable-length tweak. It is our intention to specify
    HCTR2 precisely enough to be standardized, and permitting the tweak length
    to vary is preferable to either fixing the tweak length for all users,
    or specifying a family of HCTR2 variants parameterized by tweak length.
    \item We derive \(h \gets E_k(\fromint(0))\)
    and \(L \gets E_k(\fromint(1))\) from the AES key, to make use of the
    mode more convenient.
    \item We completely redesign the polynomial hash used.
    \item We present a new proof, based on the H-coefficient technique, with a slightly tighter bound.
    \item We specify endianness and the like so that implementations can be interoperable.
    \item We rename some variables in our exposition and proof to allow some more standard usage.
    \item We provide a sample implementation and test vectors.
\end{itemize}

\subsection{Hash function design}

The polynomial hash used in HCTR2 is significantly different from
that used in HCTR. Our design goals are:

\begin{itemize}
    \item fix the flaw described in \cite{kumarhctr}
    \item allow a variable-length tweak
    \item guarantee \(H(T, M) \neq h\), required
    because \(h \gets E_k(\fromint(0))\)
    \item allow implementations to precalculate as much as possible, to reduce multiplies
\end{itemize}

See \autoref{hproperties}
for the properties we require of the hash function.

To fix the \cite{kumarhctr} flaw, we eliminate the zero-length special case
by adding one to the length before encoding it.

We swap the tweak and the message, so that implementations need only
process the tweak once for each block, instead of twice.

With the introduction of the constant \(L\)
our security proof no longer relies on the hash function
having property 2 of \cite[Section~3.3]{hctr}.
This allows us to move the length block first, so
that implementations need only process it once per block.
It is never zero, so its position in the
polynomial can be inferred from the degree.

This change means that \(\ceil{\abs{T}/n} + \ceil{\abs{M}/n}\)
can be inferred from the degree of the
polynomial. So the length block encodes
only the length of the tweak, 
with the least significant bit encoding 
whether the message is
block-multiple in length. If the message is not
block-multiple, it is padded with a one followed
by zeroes to a block-multiple length before hashing.

This encoding can eliminate a multiply for implementations that use
a fixed-length tweak but handle variable-length messages.
If all tweaks are of length \(t\), implementations can store
\(\fromint(2t + 2)h\), and use this or \(\fromint(2t + 2)h \xor h\)
to start hashing, XORing this value directly with the
first block of the tweak.

This encoding also guarantees that the length block
cannot have the value \(\fromint(1)\), which achieves
our guarantee that \(H(T, M) \neq h\).

\section{Implementation}

\printbibliography[heading=bibintoc]

\end{document}
