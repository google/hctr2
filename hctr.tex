% Copyright 2021 Google LLC
%
% Use of this source code is governed by an MIT-style
% license that can be found in the LICENSE file or at
% https://opensource.org/licenses/MIT.

%!TeX spellcheck = en-US

\documentclass[letterpaper,11pt]{article}

\usepackage{floatrow}
\usepackage{algpseudocode}
\usepackage{amsmath}
\usepackage[style=alphabetic,backend=biber,alldates=ymd]{biblatex}
\usepackage[logic,probability,advantage,adversary,landau,sets,operators]{cryptocode}
\usepackage{hyperref}
\usepackage{tikz}

\usetikzlibrary{groupops}

\addbibresource{bib.bib}

\newcommand*{\parintro}[1]{\textbf{#1}:}
\newcommand*{\Concat}{\Vert}
\newcommand*{\MM}{\mathit{MM}}
\newcommand*{\YY}{\mathit{YY}}

\DeclareMathOperator{\XCTR}{XCTR}
\DeclareMathOperator{\GF}{GF}
\DeclareMathOperator{\fromint}{bin}
\DeclareMathOperator{\intify}{int}
\DeclareMathOperator{\pad}{pad}
\DeclareMathOperator{\trunc}{trunc}
\DeclareMathOperator{\Poly}{Poly}
\DeclareMathOperator{\HCTR}{HCTR2}

\title{HCTR2}

\begin{document}
\maketitle

\begin{abstract}
\end{abstract}

\section{Introduction}
Changes from HCTR
\begin{itemize}
    \item When hashing, we write \(\abs{X} + 1\) in the last block, to fix the issue discussed above
    \item We allow a variable-length tweak; copying GHASH\cite{gcm}, 
    we include the length of message and tweak in the last block. 
    \item We process the tweak first as a small optimization
    \item We generate \(h \gets E_k(0)\)---note that the security of doing so is very sensitive to our other hashing choices
    \item We specify endianness and the like so that implementations can be interoperable
    \item We provide a sample implementation and test vectors
    \item We rename some variables in our exposition and proof to allow some more standard usage
    \item We present a new proof, based on the H-coefficient technique, with a slightly tighter bound.
\end{itemize}

we don't know of any patents etc

\section{Specification}
\begin{figure}
    \input{hctr2fig.tex}
    \caption{HCTR2}\label{hctr2fig}
\end{figure}
\begin{figure}
    \begin{floatrow}
        \ffigbox{
            \begin{algorithmic}[0]
                \Procedure{\(HCTR2_{k, T}\)}{$P$}
                \State $h \gets E_k(0^n)$
                \State $M \Concat N \gets P$, $|M| = n$
                \State $\MM \gets M \xor H_h(T, N)$
                \State $\YY \gets E_k(\MM)$
                \State $S \gets \MM \xor \YY$
                \State $Z \gets N \xor \XCTR_k(S)[0;\abs{N}]$
                \State $Y \gets \YY \xor H_h(T, Z)$
                \State $C \gets Y \Concat Z$
                \State \textbf{return} $C$
                \EndProcedure
            \end{algorithmic}
        }{
            \caption{HCTR2 encryption}\label{pseudocode}
        }
        \ffigbox{
            \begin{algorithmic}[0]
                \Procedure{\(HCTR2_{k, T}^{-1}\)}{$C$}
                \State $h \gets E_k(0^n)$
                \State $Y \Concat Z \gets C$, $|Y| = n$
                \State $\YY \gets Y \xor H_h(T, Z)$
                \State $\MM \gets E_k^{-1}(\YY)$
                \State $S \gets \MM \xor \YY$
                \State $N \gets Z \xor \XCTR_k(S)[0;\abs{Z}]$
                \State $M \gets \MM \xor H_h(T, N)$
                \State $P \gets M \Concat N$
                \State \textbf{return} $P$
                \EndProcedure
            \end{algorithmic}
        }{\caption{HCTR2 decryption}}
    \end{floatrow}
\end{figure}
\subsection{Notation}
Subscripts may denote partial application; if we define $f: A \times B \rightarrow C$ and
$a \in A$ then $f_a: B \rightarrow C$, and if $f_a^{-1}$ exists then $f_a^{-1}(f_a(b)) = b$.
\begin{itemize}
    \item $\abs{X}$: length of $X \in \bin^{*}$ in bits
    \item $\lambda$: the empty string $\abs{\lambda} = 0$
    \item $\Concat$: bitstring concatenation
    \item $Y[a;l]$: the subsequence of $Y$ of length $l$ starting at the 0-based index $a$.
    \item $\pad_l(X) = X \Concat 0^v$
    where $v$ is the least integer $\geq 0$ such that $l$ divides $\abs{X} + v$
    \item $\intify: \bin^{*} \rightarrow \ZZ$: the
    standard little-endian map such that
    $\intify(\lambda) = 0$, $\intify(0 \Concat X) = 2\intify(X)$, $\intify(1 \Concat X) = 1 + 2\intify(X)$
    \item $\fromint_l(y) = X$: the unique
    $l$-bit sequence such that $\intify(X) \equiv y \pmod{2^l}$
    \item \(n\): block size in bits. We assume \(n\) is even.
    \item \(E: \mathcal{K} \times \bin^n \rightarrow \bin^n\): 
    \(n\)-bit block cipher with keyspace \(\mathcal{K}\);
    our concrete proposal uses AES, so \(n=128\) and \(\mathcal{K}\) is
    \(\bin^{128}\), \(\bin^{192}\), or \(\bin^{256}\). 
    \item \(\xor\): bitwise XOR, addition in \(\GF(2^n)\)
    \item \(\odot\): multiplication of \(n\)-bit blocks in \(\GF(2^n)\).
    This is little-endian, so \(010^{n-2}\) is interpreted as the
    polynomial \(x\). Where \(n=128\) we reduce by the polynomial
    \(1 + x + x^2 + x^7 + x^{128}\).
\end{itemize}
We map bytes to bitstrings with \(\fromint_8\).

\subsection{Polynomial hash function}

Let \(\Poly_h(M)\) refer to polynomial evaluation in \(\GF(2^n)\),
defined where \(\abs{M} \equiv 0 \pmod n\) ie
\(\Poly_h(\lambda) = 0^n\), \(\Poly_h(M \Concat X) = (h \odot \Poly_h(M)) \xor X\) 
where \(\abs{X} = n\).
Then our hash function for key \(\abs{h} = 2^n\)
and tweak, message \(\abs{T}, \abs{N} < 2^{n/2}\) is
\begin{displaymath}
    H_h(T, M) = \Poly_h(\pad_n(T) \Concat \pad_n(M) \Concat \fromint_{n/2}(T) \Concat \fromint_{n/2}(M) \Concat 0^n)
\end{displaymath}

\subsection{XCTR mode}

HCTR depends for its proof of security
on an unusual mode of stream encryption.
\cite{hctr,hctr2} note the differences between this mode and CTR mode,
but use the same name to refer to it; for the avoidance of ambiguity
we name this mode \emph{XCTR mode}, and define:
\begin{displaymath}
    \XCTR_K(S) = E_K(S \xor \fromint(1)) \Concat E_K(S \xor \fromint(2)) \Concat E_K(S \xor \fromint(3)) \Concat \cdots
\end{displaymath}
thus generating the first \(m\) bits \(\XCTR_K(S)[0; m]\) takes \(\ceil{\frac{m}{n}}\) block cipher calls.

\subsection{HCTR2 encryption}

From these definitions, HCTR2 is as defined in \autoref{pseudocode}.
Note that what is referred to in \cite{hctr,hctr2} as \(C, \mathit{CC}, D\)
we refer to as \(Y, YY, Z\)
so that we can use \(P, C\) to refer to plaintext and ciphertext.
Tweaks may be any length from 0 to \(2^{n/2}-1\) bits, while
messages may be any length from \(n\) to \(n + 2^{n/2}-1\) bits.

\section{Security of HCTR2}

\subsection{Hash function}
For a nonempty message \(M\) the polynomial \(\Poly_h(M)\)
is of degree \(d = \frac{\abs{M}}{n} -1\), and so if
\(M\) is not all zeroes then there are at most \(d\)
keys \(h\) such that \(\Poly_h(M) = 0^n\). \(\Poly_h\)
is also insensitive to prefixed zeroes \(\Poly_h(0^n \concat M) = \Poly_h(M)\)
and linear in the second argument \(\Poly_h(M) \xor \Poly_h(M') = \Poly_h(M \xor M')\).

Define \(d(T, M) = \ceil{\frac{\abs{T}}{n}} + \ceil{\frac{\abs{M}}{n}} + 1\);
then the degree of the polynomial in \(h\) represented by \(H_h(T, M)\) is at most \(d(T, M)\).
The constant term of the polynomial underlying \(H_h(T, M)\) is always zero,
while the \(x\) term is never 0 or 1, and depends only on the lengths \((\abs{T}, \abs{M})\).
Then \(H\) has these properties:

\begin{description}
    \item[Property 1]
    For any \(T, M\) and any \(|g| = 2^n\)
    there are at most \(d(T, M)\)
    values of \(h\) such that \(H_h(T, M) = g\).
    Proof: since the \(x\) term of \(H_h(T, M) = g\) is nonzero
    the polynomial \(H_h(T, M)^ g\) is nonzero.
    Since the degree is at most \(d(T, M)\), it has
    at most that many zeroes.
    \item[Property 2] 
    \(\epsilon\)-almost-XOR-universality: 
    For any \((T_1, M_1) \neq (T_2, M_2)\) and any \(|g| = 2^n\)
    there are at most \(\max(d(T_1, M_1), d(T_2, M_2))\)
    values of \(h\) such that \(H_h(T_1, M_1) \xor H_h(T_2, M_2) = g\).
    Proof: because the map from \((T, M)\) to polynomial is injective,
    \(H_h(T_1, M_1)\) and \(H_h(T_2, M_2)\) must map onto distinct
    polynomials and therefore \(H_h(T_1, M_1) \xor H_h(T_2, M_2)\)
    must be nonzero. Because the constant term of \(H\) is zero, 

\end{description}

\subsection{Security bound}

We prove the security of HCTR2 using Patarin's H-coefficient technique. 

\printbibliography[heading=bibintoc]

\end{document}
