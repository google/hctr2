% Copyright 2021 Google LLC
%
% Use of this source code is governed by an MIT-style
% license that can be found in the LICENSE file or at
% https://opensource.org/licenses/MIT.

%!BIB program = biber
%!TeX program = lualatex
%!TeX spellcheck = en-US

\documentclass[hctr.tex]{subfiles}
\begin{document}
\section{Design of HCTR2}\label{design}
HCTR2 is intended as a successor to HCTR and retains several of the
features that make it an attractive design:
\begin{itemize}
    \item An unbalanced Feistel-like network based on universal
    hashing, with a single block encryption on the narrow side.
    This gives us excellent performance and parallelizability,
    as well as very natural handling of messages that are not
    a multiple of the block size. Contrast with eg HEH\cite{heh}:
    while HCTR requires three passes, or two if passes are
    run in parallel, HEH requires five, or three if run in parallel.
    HEH also requires a ciphertext-stealing-like trick to
    handle odd-sized messages, further increasing
    latency especially for small messages.
    \item Use of \(\MM \xor \UU\) in generating \(S\), which means
    that an adversary's control over \(S\) is very limited for both
    encryption and decryption queries; this is important in the
    proof of security.
    \item The CTR mode variant XCTR.
    Because of the extra constant \(L\), it would be straightforward
    to prove secure an HCTR2 variant that used CTR mode.
    However, unlike CTR, XCTR
    never needs to maintain a counter larger
    than needed for the message size;
    when a 128-bit nonce is used, CTR 
    must use a 128-bit counter, and is
    at risk of implementations
    whose flaws only manifest on the
    rare occasions that a counter overflows
    into the next word.
\end{itemize}

HCTR2 differs from HCTR in the following ways:

\begin{itemize}
    \item To achieve a quadratic security bound
    on queries of unbounded size,
    we introduce the extra
    key-dependent constant \(L\),
    so that where HCTR has \(S = \MM \xor \UU\)
    we have \(S = \MM \xor \UU \xor L\).
    \item We allow a variable-length tweak. It is our intention to specify
    HCTR2 precisely enough to be standardized, and permitting the tweak length
    to vary is preferable to either fixing the tweak length for all users,
    or specifying a family of HCTR2 variants parameterized by tweak length.
    \item We derive \(h \gets E_k(\fromint(0))\)
    and \(L \gets E_k(\fromint(1))\) from the block cipher key;
    this makes HCTR2 more convenient to use.
    \item We redesign the polynomial hash used, as described in
    \autoref{hashdesign}.
    \item We present a new proof, based on the H-coefficient technique,
    with a tighter bound.
    \item We specify endianness and the like so that implementations can be interoperable. We use little-endian representation everywhere,
    since this is faster on nearly all modern platforms.
    This is another difference between XCTR and CTR, since
    CTR is defined to be big-endian.
    \item We rename some variables in our exposition and proof to allow some more standard usage.
    \item We provide a sample implementation and test vectors.
\end{itemize}

\subsection{Hash function design}\label{hashdesign}

\subsubsection{Input formatting}

The formatting of inputs to the polynomial hash in HCTR2 is significantly
different from that in HCTR. Our design goals are:

\begin{itemize}
    \item fix the flaw described in \cite{kumarhctr}
    \item allow a variable-length tweak
    \item guarantee \(H(T, M) \neq h\), required
    because \(h \gets E_k(\fromint(0))\)
    \item allow implementations to precompute as much as possible, to reduce \(GF(2^n)\) multiplications
\end{itemize}

See \autoref{hproperties}
for the properties we require of the hash function.

To fix the flaw described in \cite{kumarhctr},
we eliminate the zero-length special case
by adding one to the length before encoding it.

We process the tweak before the message, so that implementations need only
process the tweak once for each encryption/decryption, instead of twice.

With the introduction of the constant \(L\)
our security proof no longer relies on the hash function
having property 2 of \cite[Section~3.3]{hctr}.
This allows us to move the length block first, so
that implementations need only process it once per encryption/decryption.
It is never zero, so its position in the
polynomial can be inferred from the degree.

This change means that \(\ceil{\abs{T}/n} + \ceil{\abs{M}/n}\)
can be inferred from the degree of the polynomial.  
If we append a 1 to the message before padding with zeroes,
we need only encode only the tweak length in the length block,
and the message length can then be inferred.
For users whose tweaks are always the same length
this means the length block is always the same, 
so the multiplication with \(h\) can be
precomputed.

However, in the very common case where 
the message length is a multiple of the block size,
we don't want an extra multiplication
for an extra block containing only the appended 1 bit.
Borrowing from~\cite{xcbc},
we don't append a 1 bit to such messages.
Instead, we indicate whether
the message length is a multiple of the block size
in the least significant bit of the length block.
If all tweaks are of length \(t\), implementations can cache
\(\fromint(2t + 2)h\), and use this or \(\fromint(2t + 2)h \xor h\)
to start hashing, XORing this value directly with the
first block of the tweak.

This encoding also guarantees that the length block
cannot have the value \(\fromint(1)\), which achieves
our guarantee that \(H(T, M) \neq h\).

\subsubsection{Alternatives considered}

Like HCTR, HCTR2's almost-XOR-universal hash function uses a standard polynomial
evaluation in $GF(2^n)$. This uses an $n$-bit key and requires $l$ field
multiplications where $l$ is the number of blocks.
We considered several alternatives:

\emph{BRW polynomials}: BRW polynomials\cite{pema}\cite{heh2} are theoretically
attractive since they only need \(\floor{l/2}\) multiplications
to evaluate. However, they pose a number of difficulties. \cite{brweval} gives a
nonrecursive algorithm that handles variable-length messages, but it is complex,
uses temporary space that grows with the message length, and does not handle
incremental computation well. Standard polynomials avoid these issues;
fast and correct implementations are easier to write,
and implementers have much more control over
code size, precomputation, instruction-level
parallelism, number of reductions, and so forth.
Finally, preserving our guarantees of injectivity on variable-length
tweaks and messages, and the other hash function properties we need
to guarantee, proved challenging.

\emph{Polynomials over non-binary fields}: When CPU instructions for carryless
multiplication are unavailable, hashes using non-binary fields such as
Poly1305\cite{poly1305} tend to be faster than hashes using binary fields.
However, HCTR2 primarily targets
processors that support carryless multiplication, 
and on such processors hashes
using binary fields tend to be faster and simpler.

\emph{Multivariate hashes}: Adiantum\cite{adiantum} builds an
almost-$\Delta$-universal hash function using the multivariate hash
NH\cite{umac1} combined with polynomial evaluation. Where NH is faster than
polynomial evaluation, this increases performance. However, this adds
complexity, and NH requires a long key which needs to be derived and cached. 
HCTR2 primarily targets processors where polynomial evaluation is fast, so
we do not add an NH layer.

\emph{Field convention}: Unlike HCTR, HCTR2 specifies the bit and byte order of
field elements. Reusing the convention of GHASH from GCM\cite{gcm} is somewhat
attractive, since it is widely deployed and code could be shared. However,
GHASH's mapping between bits and polynomial coefficients is backwards from the
natural order, which increases implementation complexity and reduces efficiency.
Due to this issue, we instead use the natural order.

\end{document}
