% Copyright 2021 Google LLC
%
% Use of this source code is governed by an MIT-style
% license that can be found in the LICENSE file or at
% https://opensource.org/licenses/MIT.

%!BIB program = biber
%!TeX program = lualatex
%!TeX spellcheck = en-US

\documentclass[hctr.tex]{subfiles}
\begin{document}
\section{Design of HCTR2}\label{design}
HCTR2 is intended as a successor to HCTR and retains several of the
crucial features that make it an attractive design:
\begin{itemize}
    \item An unbalanced Feistel-like network based on universal
    hashing, with a single block encryption on the narrow side.
    This gives us excellent performance and parallelizability,
    as well as very natural handling of messages that are not
    a multiple of the block size. Contrast with eg HEH\cite{heh}:
    while HCTR requires three passes, or two if passes are
    run in parallel, HEH requires five, or three if run in parallel.
    HEH also requires a ciphertext-stealing-like trick to
    handle odd-sized messages, further increasing
    latency especially for small messages.
    \item Use of \(\MM \xor \UU\) in generating \(S\), which means
    that an adversary's control over \(S\) is very limited for both
    encryption and decryption queries; this is important in the
    proof of security.
    \item The CTR mode variant XCTR; HCTR2, unlike HCTR,
    does not require this mode for its security proofs, 
    but we prefer not to change it unnecessarily.
    XCTR also never needs to maintain a counter larger
    than needed for the message size;
    when a 128-bit nonce is used, CTR 
    must use a 128-bit counter, and is
    at risk of implementations
    whose flaws are only manifest on the
    rare occasions that a counter overflows
    into the next word.
\end{itemize}

HCTR2 differs from HCTR in the following ways:

\begin{itemize}
    \item To achieve a quadratic security bound
    on queries of unbounded size,
    we introduce the extra
    key-dependent constant \(L\),
    so that where HCTR has \(S = \MM \xor \UU\)
    we have \(S = \MM \xor \UU \xor L\).
    \item We allow a variable-length tweak. It is our intention to specify
    HCTR2 precisely enough to be standardized, and permitting the tweak length
    to vary is preferable to either fixing the tweak length for all users,
    or specifying a family of HCTR2 variants parameterized by tweak length.
    \item We derive \(h \gets E_k(\fromint(0))\)
    and \(L \gets E_k(\fromint(1))\) from the block cipher key;
    this makes HCTR2 more convenient to use.
    \item We completely redesign the polynomial hash used, as described in
    \autoref{hashdesign}.
    \item We present a new proof, based on the H-coefficient technique,
    with a tighter bound.
    \item We specify endianness and the like so that implementations can be interoperable.
    \item We rename some variables in our exposition and proof to allow some more standard usage.
    \item We provide a sample implementation and test vectors.
\end{itemize}

\subsection{Hash function design}\label{hashdesign}

The polynomial hash used in HCTR2 is significantly different from
that used in HCTR. Our design goals are:

\begin{itemize}
    \item fix the flaw described in \cite{kumarhctr}
    \item allow a variable-length tweak
    \item guarantee \(H(T, M) \neq h\), required
    because \(h \gets E_k(\fromint(0))\)
    \item allow implementations to precalculate as much as possible, to reduce \(GF(2^n)\) multiplies
\end{itemize}

See \autoref{hproperties}
for the properties we require of the hash function.

To fix the \cite{kumarhctr} flaw, we eliminate the zero-length special case
by adding one to the length before encoding it.

We swap the tweak and the message, so that implementations need only
process the tweak once for each encryption/decryption, instead of twice.

With the introduction of the constant \(L\)
our security proof no longer relies on the hash function
having property 2 of \cite[Section~3.3]{hctr}.
This allows us to move the length block first, so
that implementations need only process it once per encryption/decryption.
It is never zero, so its position in the
polynomial can be inferred from the degree.

This change means that \(\ceil{\abs{T}/n} + \ceil{\abs{M}/n}\)
can be inferred from the degree of the polynomial.  
If we append a 1 to the message before padding with zeroes,
we need only encode only the tweak length in the length block,
and the message length can then be inferred.
For users whose tweaks are always the same length
this means the length block is always the same, 
so the multiplication with \(h\) can be
precalculated.

However, in the very common case where the message
is a block-multiple in length,
we don't want an extra multiply
for an extra block containing only the appended 1 bit.
Borrowing from~\cite{xcbc},
we append no 1 bit to such messages.
Instead, we indicate whether the message is block-multiple in length
in the least significant bit of the length block.
If all tweaks are of length \(t\), implementations can store
\(\fromint(2t + 2)h\), and use this or \(\fromint(2t + 2)h \xor h\)
to start hashing, XORing this value directly with the
first block of the tweak.

This encoding also guarantees that the length block
cannot have the value \(\fromint(1)\), which achieves
our guarantee that \(H(T, M) \neq h\).

% mention BRW?
\end{document}
